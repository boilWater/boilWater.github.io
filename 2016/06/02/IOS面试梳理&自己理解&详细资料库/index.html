<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>IOS面试&amp;自己理解&amp;详细资料库 | JackJin's 博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">IOS面试&amp;自己理解&amp;详细资料库</h1><a id="logo" href="/.">JackJin's 博客</a><p class="description">一位脚踏实地，拥有梦想的90后，想要一直努力追上你！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">IOS面试&amp;自己理解&amp;详细资料库</h1><div class="post-meta">Jun 2, 2016<span> | </span><span class="category"><a href="/categories/IOS/">IOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/06/02/IOS面试梳理&amp;自己理解&amp;详细资料库/" href="/2016/06/02/IOS面试梳理&amp;自己理解&amp;详细资料库/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>开启关于IOS面试之路总结，说实话目前IOS开发真是太多很多情况下大家情况良莠不齐很难分辨。目前还是在广州，其实还是很开心的，因为这里有自己😍事物所在。</p>
<h3 id="OC的理解和特性"><a href="#OC的理解和特性" class="headerlink" title="OC的理解和特性"></a>OC的理解和特性</h3><p>作为开发者我们都知道语言的特性包括：面对对象，面向过程。Objc就是关于面对对象语言，也就包括面向对象的特点：封装、继承、多态。下面是对三者优点列表😉</p>
<ul><br><li>封装：对于要处理的问题进行模块开发，好处有利于我们对于功能的拓展</li><br><li>继承：通过继承实现对父类方法的实现，也可以在子类中重写父类方法</li><br><li>多态：通过同名函数但是输入形式参数的种类，数目，类型不同实现具体函数功能不同（具体实现可以参照C&amp;C++在编译后形式~想了解的可以自己查找）</li><br></ul><br>Objc的动态特性：动态类型、动态加载、动态绑定。其实前面我们在runtime的理解过程中有所讲解。<a href="http://boilwater.github.io/2016/05/29/runtime理解/" target="_blank" rel="external">参考地址</a><br><ul><br><li>动态类型：在IOS中我们经常见到id类型，id类型指在Objc中动态类型。在实际应用中我们一般使用静态类型，静态类型：固定和可预知性。静态类型是强类型，动态类型是弱类型。例如：我们经常见到的protrcol委托协议就是采取@proerty(nonatomic, weak) id<protrcol> delegate</protrcol></li><br><li>动态加载：基于动态类型，在某个实例对象被确定后，其类型便被确定了，该对象对应的属性和响应消息也被完全确定。</li><br><li>动态绑定：是我们在适配机型加载过程中，动态实现图片的实现。例如，在Retina设备上加载@2x的图片。</li><br></ul>

<h3 id="内存管理原则"><a href="#内存管理原则" class="headerlink" title="内存管理原则"></a>内存管理原则</h3><ul><br><li>IOS5.0之前：在IOS 5.0之前Objc内存管理试行谁创建，谁释放的原则。如果要对是初始化的类型进行alloc,retain,copy，就需要手动进行release进行释放。当计数为0时才会释放对应的初始化内存空间和指针，我们称为MRC时代。</li><br><li>IOS 5.0之后：使用戏言IOS开发那就是一个字：爽。在ARC：自动计数模式开发程序，我们不用再手动释放申请的对象，程序开发过程终于见不到release,autorelease,retain语句。不过我们这是就该注意到strong和weak的细微区别。</li><br></ul>

<hr>
<p>strong &amp; weak区别</p>
<ul><br><li>strong:用来修饰强引用属性</li><br><li>weak:用来修饰弱引用属性</li><br></ul><br>strong &amp; weak实现具体情况<br><ul><br><li>我们知道strong的使用时强引用，使用强引用使我们在赋值时会使计数器+1；<br><br><br>释放时间：当指针指向新值或者指针不存在，指针不存在一般是在自动计数为0时指针会自动释放。</li><br><li>weak是弱引用，悲剧的是弱引用是不会再计数+1的。不过这也使我们在使用时很方便，因为我们如果要防止block中发生循环引用的时候，可以在block外使用_weak进行修饰。<br><br><br>释放时间：对象的拥有者指向新值或者不存在时weak修饰的指针会自动置为nil。<br><br><br>weak的实现原理：在每一个类中都有一个弱引用的列表，在释放时都会对列表进行访问。如果找到相应的对象就执行释放。<br><br><br>Strong：是通过ARC的自动计数来实现对于对象的释放。<br></li><br></ul>

<hr>
<p><a href="http://blog.csdn.net/leikezhu1981/article/details/42697977" target="_blank" rel="external">参考资料</a></p>
<ul><br><li>在想一个对象发送autorelease消息时，其实目标不会立即释放，会有一个具体的时间值。在autorelease调用的时候，会对其中的对象挨个发送release语句对于每个对象进行相应的释放。后面会对于autorelease进行专项讲解，不过这里可以给大牛资料，下文</li><br><li>在ARC中我们不用手动向实例化对象发送release进行释放，但是在MRC中就需要我们对申请的对象进行手动释放对象。那么问题来啦，对象会立即释放吗？<br><br><br>记住一点在MRC也是对象有时也不会立即释放，需要当前对象的计数为0时才会使用dealloc进行对象中所有的内容。<br></li><br></ul><br><a href="http://www.cocoachina.com/ios/20150610/12093.html" target="_blank" rel="external">AutoreleasePool大牛的资料</a><br><br>#### 其他注意事项<br><br><ul><br><li>当一个对象被_strong指向时，该对象是不会被释放的。但是当对象在超出其作用区域时（在C++中局部变量在超出作用区域就会nil），此时指针也会被置为nil于此同时指针所指的内存空间也会被释放。<br><br><br>还有就是当试图控制器（ViewController）进行释放，其中的全局变量和局部变量都会被释放。也有意外就是实现循环引用，恭喜你好好修改下吧，因为这是个BUG。<br></li><br><li>局部变量：上面讲到的局部变量如果超出其范围就会置为nil</li><br><li>在方法中对象创建，为啦使内存能够尽可能的减少可以使用autoreleasepool。使用方法：@autoreleasepool{};</li><br><li>block中为了避免循环引用就会使用_weak进行修饰</li><br><li>ARC不是万能的🔑：ARC是基于在Foundation之上进行的变量的管理，如果是CGtypeRef类型就无法进行管理。例如：CGImageRef的图片的信息</li><br><li>同样我们可以实现ARC和非ARC之间的进行混合编译，具体操作如下：<br><br><br>在ARC中进行非ARC程序的混合编译：-fno-fobjc-arc;<br><br><br>在非ARC中进行ARC的混合编译：-fobjc-arc;<br><br><br>不过目前我们使用ARC较多，所以使用第一种的情形较多。swift毕竟也发布两年之久，很多创业公司已经开始使用swift<br></li><br></ul>



<h4 id="拓展介绍"><a href="#拓展介绍" class="headerlink" title="拓展介绍"></a>拓展介绍</h4><hr>
<ul><br><li>nonatomic:原子操作，禁止多线程进行操作</li><br><li>atomic:原子操作，多线程安全是property的默认操作基本类型</li><br><li>assign:表示设置器可以直接进行复制，基本用于基本数据类型（NSInteger,CGFloat）和C语言的基本数据类型（int,float,double,char）</li><br><li>readwrite:可以进行读写</li><br><li>readonly:进行只读</li><br><li>copy:在赋值过程中传入一份值得copy，地址和内容都会重新赋值</li><br><li>retain:在赋值过程中会使用retain对象，指向内容的指针会copy</li><br></ul>

<hr>
<p><a href="http://blog.csdn.net/Mars2639/article/details/7352540" target="_blank" rel="external">详细内容参考地址</a></p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>开发过程中我们都会使用到设计模式，这里就以两种设计模式进行举例：</p>
<h4 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h4><p>MVC是一种架构模式，M表示MOdel，V表示视图View，C表示控制器Controller：<br>其实重要的还是需要自己动手亲自实现，这样可以锻炼自己的编码能力。<br><a href="http://www.cocoachina.com/design/20130917/7009.html" target="_blank" rel="external">资料点击</a>。</p>
<ul><br><li>Model负责存储、定义、操作数据；</li><br><li>View用来展示书给用户，和用户进行操作交互；</li><br><li>Controller是Model和View的协调者，Controller把Model中的数据拿过来给View用。Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，MOdel也要与Controller进行通信，这个时候就要用Notification和KVO，这个方式就像一个广播一样，MOdel发信号，Controller设置监听接受信号，当有数据更新时就发信号给Controller，Model和View不能直接进行通信，这样会违背MVC设计模式。</li><br></ul>

<h4 id="MVVM设计模式"><a href="#MVVM设计模式" class="headerlink" title="MVVM设计模式"></a>MVVM设计模式</h4><p>这里关于MVVM的设计模式就不多说，因为目前还没有使用过。<br><br><a href="http://www.cocoachina.com/ios/20160301/15425.html" target="_blank" rel="external">MVVM参考资料地址</a><br><br><a href="http://www.cocoachina.com/ios/20160517/16309.html" target="_blank" rel="external">MVVM升级到MVVMM</a><br><br><a href="http://www.cocoachina.com/ios/20160330/15823.html" target="_blank" rel="external">MVVM With ReactiveCocoa</a></p>
<h3 id="Objc中的协议"><a href="#Objc中的协议" class="headerlink" title="Objc中的协议"></a>Objc中的协议</h3><p>我们在IOS开发过程中我们经常会使用协议和代理模式来进行消息传递，协议一般是伴随着代理产生而产生。我们在实现协议的同时一般都会有代理形式进行完成。<br>协议中有两个属性：</p>
<ul><br><li>@required:是表明此中的方法一定要实现，在我们使用UITableViewDataSourceDelete就有两个必须实现的方法</li><br><li>@optional:方法可以根据自己选着实现方法</li><br></ul><br>在博客中有关于protrcol的相关使用<br><br><br><a href="http://boilwater.github.io/2016/05/29/block，注册监听，委托协议和KVO/" target="_blank" rel="external">参考地址</a><br><br>### Category的优缺点<br>我们使用Category一般是在一个现有类中定向添加方法，其实我们使用常见的SDWebImage本质就是一个类的类目：UIImageView<br>优点：<br><ul><br><li>我们在一个现有类中可以增加方法，于此同时我们又不需要改变原来对象的属性。增加方法和原来方法使用是一样的</li><br><li>在多方法的使用过程中我们可以通过使用Category实现对类进行区分，达到方便管理类种方法的原则</li><br></ul>

<p>缺点：</p>
<ul><br><li>Category允许我们对类进行添加特定方法，但是我们不能向类中添加成员变量。但是我们可以继承类在子类中进行相关成员属性添加</li><br><li>在增加方法的过程中，我们增加方法的优先级别比较高因此会覆盖父类中的方法。例如：在界面我们相应手指触摸时有响应链，如果在子类中调用touch方法没有调用父类就会使响应者连中断</li><br></ul>

<p><a href="http://www.cocoachina.com/ios/20120614/4361.html" target="_blank" rel="external">Objective-C Category初体验</a><br> <br><br><a href="http://www.cocoachina.com/ios/20140212/7808.html" target="_blank" rel="external">Objective-C相关Category的收集</a></p>
<h3 id="键路径-keyPath-、键值编码（KVC）和键值观察（KVO）"><a href="#键路径-keyPath-、键值编码（KVC）和键值观察（KVO）" class="headerlink" title="键路径(keyPath)、键值编码（KVC）和键值观察（KVO）"></a>键路径(keyPath)、键值编码（KVC）和键值观察（KVO）</h3><p>在我的博客中有所讲述，在这里就不赘述啦。不过这里给大家留一个问题？为什么使用KVC（Key-value-coding）在效率不是很高？<br><br><a href="http://boilwater.github.io/2016/05/29/block%EF%BC%8C%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%EF%BC%8C%E5%A7%94%E6%89%98%E5%8D%8F%E8%AE%AE%E5%92%8CKVO/" target="_blank" rel="external">参考路径</a><br>其他参考资料：<br><br><a href="http://www.cocoachina.com/ios/20160408/15868.html" target="_blank" rel="external">谈KVC、KVO（重点观察者模式）机制编程</a><br><br><br><a href="http://www.cocoachina.com/ios/20140224/7866.html" target="_blank" rel="external">iOS KVC &amp; KVO</a></p>
<h3 id="NSNotification、Block、Delegate和KVO的区别"><a href="#NSNotification、Block、Delegate和KVO的区别" class="headerlink" title="NSNotification、Block、Delegate和KVO的区别"></a>NSNotification、Block、Delegate和KVO的区别</h3><p>博客中有详细介绍<br><br><br><a href="http://boilwater.github.io/2016/05/29/block%EF%BC%8C%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%EF%BC%8C%E5%A7%94%E6%89%98%E5%8D%8F%E8%AE%AE%E5%92%8CKVO/" target="_blank" rel="external">详细参看</a></p>
<h3 id="Objective-C中可修改和不可以修改类型"><a href="#Objective-C中可修改和不可以修改类型" class="headerlink" title="Objective-C中可修改和不可以修改类型"></a>Objective-C中可修改和不可以修改类型</h3><p>可修改和不可修改的集合类，我们在IOS开发过程中经常会遇到NSArray和NSMutableArray两种，两者的区别：</p>
<ul><br><li>一个是可以动态添加，一个不可以动态添加</li><br><li>前者初始化后内存是固定不边的，后者经过初始化内存是可以发生改变的</li><br></ul>

<hr>
<p>这里我就引出一个概念：非容器对象和容器对象。</p>
<ul><br><li>非容器对象：NSNumber，NSSting等只能放单个字符或者数字</li><br><li>容器对象：NSArray，NSDictionary等可以放置多个数据类型</li><br></ul><br>但是在我们熟悉的copy过程中会发生哪些情况呢？<br><br>这里又提出另外的cop的新概念：copy, mutableCopy<br><ul><br><li>copy：复制了一个imutable的对象+ copyWithZone:</li><br><li>mutableCopy：复制的是一个mutable的对象，使用的方法+ mutableCopyWithZone:</li><br></ul><br>下面我们给出在非容器对象复制后的具体情况<br><br>非容器对象     | 不变类（NSString） |  可变类（NSMustbleString）<br>———— | ——————| ————<br>copy         | 浅Copy            | 深Copy~返回的对象是不可变的对象<br>mutableCopy  | 深Copy            | 深Copy<br><br>下面我们给出容器对象中复制的具体情况<br><br>容器类型      | 不变类型（NSArray） | 可变类型（NSMutableArray）<br>———— | —————- | ————<br>copy         | 浅copy            | 深copy<br>mutableCopy  | 深copy            | 深copy<br><br><div style="color:#008B8B"><br><p>但是在容器对象复制过程中我们需要记住一点，我们对于NSArray和NSMutable的copy是对于整体指针和内存来说。但是在容器内部每一个元素我们进行的都是指针copy,也就是我们所说的浅copy。</p><br></div><br>从上面列举的例子我们可以得出一个结论：<br><ul><br><li>无论是非容器类型还是容器类型只有在不可变时（NSArray，NSString）使用copy才是浅复制，也就是说只是复制指针而不复制内存。</li><br><li>在可变的类型（NSMutableString, NSMutableArray）在使用copy时会生成不可变类型。</li><br></ul><br>具体为什么实现这种原理可以看下在NSArray和NSMutable实现接口，以及参照C++的原理进行解释。<br><br>—<br><br>下面是参考资料：<br><br><a href="http://www.fanliugen.com/?p=278" target="_blank" rel="external">copy与mutableCopy</a><br><br><a href="http://www.cnblogs.com/-Eric-Liu/p/5564030.html" target="_blank" rel="external">NSArray与NSMutableArray的区别</a><br><br>### 当我们调用一个静态方法时,需要对对象进行 release 吗?<br><br>不要对静态方法进行释放，因为静态方法会放到自动释放池中，后面会自动释放。<br><br>我在博客中写过关于Runtime的解析，在那里我们可以看出一个类在解析过程中其中类中调用方法是Method形式，放在Struct的Class中的。执行过程AutoReleasePool会进行管理。<br><br><a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="external">深入理解RunLoop</a>大神文章写得很详细<br><br>### 当我们释放我们的对象时,为什么需要调用[super dealloc]方法,它的位置又是如何的呢?<br><br>因为子类的某些实例是继承自父类的,因此需要调用[super dealloc]方法, 来释放父类拥有的实例,其实也就是子类本身的。一般来说我们优先释放子类拥 有的实例,最后释放父类所拥有的实例。<br><br>### static、self、super关键字的作用<br><br>static 是在C和C++中经常使用的，在Objc中我们也是常常使用static来定义cell的identifer目前就想到这些。下面给出static的具体作用：<br><ul><br><li>static修饰的变量只是在第一次调用过程进行初始化，所以在第二次调用时会维持上一次的值</li><br><li>在模块内我们使用的static变量可以在模块中所有函数使用，但是在模块外就不可以进行访问</li><br><li>在模块内的static的函数只能被模块内的函数进行调用，不能被模块外的其他函数声明</li><br><li>在类中的satic的全局变量，在整个类中有且仅仅只有一份的copy</li><br></ul><br>self: 是我们在当前类消息的接受者<br><br>super: 是我们调用父类的方法，消息链过程中我们在touch调用super就是调用父类方法，防止消息链中断。<br><br>### #include与#import的区别，#import 与@class 的区别<br><br><ul><br><li>#include是我们在C/C++经常使用到的引入到文件的方式</li><br><li>#import是我们在Objc中使用引入头文件的方式，可以防止头文件被多次引用（如果头文件被多次应用，程序在编译过程中会把库函数编译到类中这样就占用较多内存）</li><br><br>#import和@class两者之间的区别<br><li>@class是只是定义类名，对其中的行为并不知道，我们经常可以再很多类的.h文件可以看到</li><br><li>@class由于仅仅是定义类的名字，所以在编译过程要比import的效率高</li><br><li>此外@class 和#import 的主要区别在于解决引用死锁的问题</li><br></ul><br><a href="http://www.cnblogs.com/stevenschen/p/3825044.html" target="_blank" rel="external">参考资料点击</a><br><br>### @public、@protected、@private 它们的含义与作用<br><br><ul><br><li>@public:对象的实例变量的作用域在任意地方都可以被访问</li><br><li>@protected:对象的实例变量作用域在本类和子类都可以被访问</li><br><li>@private:实例变量的作用域只能在本类(自身)中访问 </li><br></ul>

<h3 id="解释-id-类型"><a href="#解释-id-类型" class="headerlink" title="解释 id 类型"></a>解释 id 类型</h3><p>任意类型对象，程序运行时才决定对象的类型。 这也是我们在上面解释的动态类型。</p>
<h3 id="switch-语句-if-语句区别与联系"><a href="#switch-语句-if-语句区别与联系" class="headerlink" title="switch 语句 if 语句区别与联系"></a>switch 语句 if 语句区别与联系</h3><p>两者均是判断语句。但是switch只可以判断整形，字符型，枚举类型；但是if并没有类型限制。</p>
<h3 id="isMemberOfClass-和-isKindOfClass-联系与区别"><a href="#isMemberOfClass-和-isKindOfClass-联系与区别" class="headerlink" title="isMemberOfClass 和 isKindOfClass 联系与区别"></a>isMemberOfClass 和 isKindOfClass 联系与区别</h3><ul><br><li>两者都可以判断一个对象是否是某个类的成员</li><br><li>isKindOfClesss不紧可以判断对象是否是一个类的成员，也可以判断一个对象是否派生于类的类成员</li><br><li>举例：如 ClassA派 生 自NSObject 类 , ClassA *a = [ClassA alloc] init];,[a isKindOfClass:[NSObject class]] 可以检查出 a 是否是 NSObject派生类 的成员,但 isMemberOfClass 做不到</li><br></ul>

<h3 id="iOS-开发中数据持久性有哪几种"><a href="#iOS-开发中数据持久性有哪几种" class="headerlink" title="iOS 开发中数据持久性有哪几种?"></a>iOS 开发中数据持久性有哪几种?</h3><p><a href="http://boilwater.github.io/2016/05/29/IOS%E7%9A%84%E6%B0%B8%E4%B9%85%E8%AF%9D%E5%82%A8%E5%AD%98/" target="_blank" rel="external">参考资料~IOS的永久话储存</a></p>
<h3 id="自动释放池工作原理"><a href="#自动释放池工作原理" class="headerlink" title="自动释放池工作原理"></a>自动释放池工作原理</h3><p><a href="http://www.cocoachina.com/ios/20160602/16569.html" target="_blank" rel="external">自动释放池的前世今生</a><br><br><a href="http://www.cocoachina.com/ios/20150610/12093.html" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/06/02/IOS面试梳理&amp;自己理解&amp;详细资料库/" data-id="ciqnzq0to0007nu42y0jz7sgd" class="article-share-link">分享到</a><div class="tags"><a href="/tags/IOS基础知识/">IOS基础知识</a></div><div class="post-nav"><a href="/2016/06/03/SDWebImage/" class="pre">SDWebImage之图片下载</a><a href="/2016/05/29/cocoaPods使用和静态库的建立/" class="next">cocoaPods使用和静态库的建立</a></div><div id="disqus_thread"><script>var disqus_shortname = 'JackJin## Your disqus_shortname, e.g. username';
var disqus_identifier = '2016/06/02/IOS面试梳理&amp;自己理解&amp;详细资料库/';
var disqus_title = 'IOS面试&amp;自己理解&amp;详细资料库';
var disqus_url = 'http://yoursite.com/2016/06/02/IOS面试梳理&amp;自己理解&amp;详细资料库/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//JackJin## Your disqus_shortname, e.g. username.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/第三方框架/">第三方框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-图层-动画/">视图&图层&动画</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/IOS/" style="font-size: 15px;">IOS</a> <a href="/tags/IOS基础知识/" style="font-size: 15px;">IOS基础知识</a> <a href="/tags/三方框架解析/" style="font-size: 15px;">三方框架解析</a> <a href="/tags/图片视频/" style="font-size: 15px;">图片视频</a> <a href="/tags/视频心得/" style="font-size: 15px;">视频心得</a> <a href="/tags/博客之初/" style="font-size: 15px;">博客之初</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/UIView&CALayer&Core Animation~1/">UIView & CALayer& Core Animation ~ （UIView 和 CALayer）（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/UIView&CALayer&Core Animation-总体/">UIView&CALayer&Core Animation~开篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/15/IOS 10/">IOS 10.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/04/SDWebImage之图片缓存分析/">SDWebImage之图片缓存处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/03/SDWebImage/">SDWebImage之图片下载</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/02/IOS面试梳理&自己理解&详细资料库/">IOS面试&自己理解&详细资料库</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最新评论</i></div><script type="text/javascript" src="//JackJin## Your disqus_shortname, e.g. username.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="https://github.com/boilWater" title="Github" target="_blank">Github</a><ul></ul><a href="http://weibo.com/u/2815612403?is_all=1" title="微博" target="_blank">微博</a><ul></ul><a href="http://www.jianshu.com/users/c48ed5ae3925/latest_articles" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">JackJin's 博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SDWebImage之图片下载 | JackJin's 博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SDWebImage之图片下载</h1><a id="logo" href="/.">JackJin's 博客</a><p class="description">一位脚踏实地，拥有梦想的90后，想要一直努力追上你！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SDWebImage之图片下载</h1><div class="post-meta">Jun 3, 2016<span> | </span><span class="category"><a href="/categories/第三方框架/">第三方框架</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/06/03/SDWebImage/" href="/2016/06/03/SDWebImage/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>我们经常使用SDWebImage在加载图片，但对于图片加载过程中怎么样实现不会深究。下面我们就对SDWebImage进行相应的分析：<br><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">源码地址</a></p>
<h2 id="SDWebImage的下载器"><a href="#SDWebImage的下载器" class="headerlink" title="SDWebImage的下载器"></a>SDWebImage的下载器</h2><p>SDWebImage的下载器是SDWebImageDownloader利用单例模式sharedDownloader，可以对下载的图片进行相关配置。可以配置的部分如下：</p>
<p><ul></ul></p>
<p><li>下载选项</li></p>
<p><li>HTTP的头部</li></p>
<p><li>压缩、下载超时、下载顺序、最大并发数等</li><br></p>
<h3 id="下载选项"><a href="#下载选项" class="headerlink" title="下载选项"></a>下载选项</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">   <span class="comment">//下载的优先级</span></span><br><span class="line">   SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">   <span class="comment">//下载进度</span></span><br><span class="line">   SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">   <span class="comment">//下载路径缓存</span></span><br><span class="line">   SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">   <span class="comment">//下载过程的请求缓存</span></span><br><span class="line">   SDWebImageDownloaderIgnoreCachedResponse = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">   <span class="comment">//后台进行继续下载</span></span><br><span class="line">   SDWebImageDownloaderContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    </span><br><span class="line">   SDWebImageDownloaderHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">   </span><br><span class="line">   SDWebImageDownloaderAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">   </span><br><span class="line">   SDWebImageDownloaderHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="HTTP的头部设置"><a href="#HTTP的头部设置" class="headerlink" title="HTTP的头部设置"></a>HTTP的头部设置</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdef SD_WEBP</span></span><br><span class="line">        _HTTPHeaders = [@&#123;<span class="string">@"Accept"</span>: <span class="string">@"image/webp,image/*;q=0.8"</span>&#125; mutableCopy];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">        _HTTPHeaders = [@&#123;<span class="string">@"Accept"</span>: <span class="string">@"image/*;q=0.8"</span>&#125; mutableCopy];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setValue:(<span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="built_in">NSString</span> *)field &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="keyword">self</span>.HTTPHeaders[field] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.HTTPHeaders removeObjectForKey:field];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="built_in">NSString</span> *)field &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.HTTPHeaders[field];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过上述forHTTPHeaderField的参数进行相应HTTPheader的设置，使用者可以对头部信息进行相关的添加或者是删除HTTP头部信息。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在图片下载过程中我们要保线程访问的安全性，barrierQueue是实现网络响应的序列化实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// This queue is used to serialize the handling of the network responses of all</span><br><span class="line">the download operation in a single queue</span><br><span class="line">@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t barrierQueue;</span><br></pre></td></tr></table></figure></p>
<p>在保证线程安全的起见，我们对于URLCallbacks进行增改都需要放在dispatch_barrier_sync的形式放入到barrierQueue。但是如果我们只要进行相关的查询那就使用dispatch_sync放入barrierQueue中即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__block <span class="built_in">NSArray</span> *callbacksForURL;</span><br><span class="line"><span class="built_in">dispatch_sync</span>(sself.barrierQueue, ^&#123;</span><br><span class="line">    callbacksForURL = [sself.URLCallbacks[url] <span class="keyword">copy</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.URLCallbacks[url]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.URLCallbacks[url] = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        first = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Handle single download of simultaneous download request for the same URL</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span>.URLCallbacks[url];</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line"><span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</span><br><span class="line"><span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</span><br><span class="line">[callbacksForURL addObject:callbacks];</span><br><span class="line"><span class="keyword">self</span>.URLCallbacks[url] = callbacksForURL;</span><br><span class="line"><span class="keyword">if</span> (first) &#123;</span><br><span class="line">      createCallback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>在我们下载图片的过程中，每一张图片都需要开启一个线程，在每一个线程中都需要对执行一定的回调信息。这些回调的信息会以block的实行出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize,</span><br><span class="line">NSInteger expectedSize);</span><br><span class="line"></span><br><span class="line">typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data,</span><br><span class="line">NSError *error, BOOL finished);</span><br><span class="line"></span><br><span class="line">typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, </span><br><span class="line">NSDictionary *headers);</span><br></pre></td></tr></table></figure><br>图片下载的这些回调信息存储在SDWebImageDownloader类的URLCallbacks属性中，该属性是一个字典，key是图片的URL地址，value则是一个数组，包含每个图片的多组回调信息。</p>
<h3 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h3><p>整个下载过程中我们需要执行在本小结讲述的下载器中进行，下载器对于下载的管理都是放在-(id <sdwebimageoperation>)downloadImageWithURL:中的：</sdwebimageoperation></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">__block SDWebImageDownloaderOperation *operation;</span><br><span class="line">__weak __typeof(self)wself = self;</span><br><span class="line">[self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">        NSTimeInterval timeoutInterval = wself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval == 0.0) &#123;</span><br><span class="line">            timeoutInterval = 15.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line"></span><br><span class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? </span><br><span class="line">NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData)</span><br><span class="line">timeoutInterval:timeoutInterval];</span><br><span class="line">request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">request.HTTPShouldUsePipelining = YES;</span><br><span class="line">      if (wself.headersFilter) &#123;</span><br><span class="line">          request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          request.allHTTPHeaderFields = wself.HTTPHeaders;</span><br><span class="line">      &#125;</span><br><span class="line">      operation = [[wself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                        options:options</span><br><span class="line">                                                       progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line">                                                           SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                           if (!sself) return;</span><br><span class="line">                                                           __block NSArray *callbacksForURL;</span><br><span class="line">                                                           dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                               callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                           &#125;);</span><br><span class="line">                                                           for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                               dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                   SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">                                                                   if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                               &#125;);</span><br><span class="line">                                                           &#125;</span><br><span class="line">                                                       &#125;</span><br><span class="line">                                                      completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                                                          SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                          if (!sself) return;</span><br><span class="line">                                                          __block NSArray *callbacksForURL;</span><br><span class="line">                                                          dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                              callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                              if (finished) &#123;</span><br><span class="line">                                                                  [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                              &#125;</span><br><span class="line">                                                          &#125;);</span><br><span class="line">                                                          for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                              SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                              if (callback) callback(image, data, error, finished);</span><br><span class="line">                                                          &#125;</span><br><span class="line">                                                      &#125;</span><br><span class="line">                                                      cancelled:^&#123;</span><br><span class="line">                                                          SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                          if (!sself) return;</span><br><span class="line">                                                          dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                              [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                          &#125;);</span><br><span class="line">                                                      &#125;];</span><br><span class="line">      operation.shouldDecompressImages = wself.shouldDecompressImages;</span><br><span class="line">      </span><br><span class="line">      if (wself.urlCredential) &#123;</span><br><span class="line">          operation.credential = wself.urlCredential;</span><br><span class="line">      &#125; else if (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line">          operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">          operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">      &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">          operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      [wself.downloadQueue addOperation:operation];</span><br><span class="line">      if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">          // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</span><br><span class="line">          [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">          wself.lastAddedOperation = operation;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在上面的方法中调用的方法(void)addProgressCallback:completedBlock:forURL:createCallback:将在访问图片请求的信息直接放入下载器。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(<span class="built_in">NSURL</span>*)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line"><span class="comment">// The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</span><br><span class="line">   <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">self</span>.URLCallbacks[url]) &#123;</span><br><span class="line">       <span class="keyword">self</span>.URLCallbacks[url] = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">       first = <span class="literal">YES</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Handle single download of simultaneous download request for the same URL</span></span><br><span class="line">   <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span>.URLCallbacks[url];</span><br><span class="line">   <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">   <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</span><br><span class="line">   <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</span><br><span class="line">   [callbacksForURL addObject:callbacks];</span><br><span class="line">   <span class="keyword">self</span>.URLCallbacks[url] = callbacksForURL;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (first) &#123;</span><br><span class="line">       createCallback();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="下载操作"><a href="#下载操作" class="headerlink" title="下载操作"></a>下载操作</h3><p>在每张图片下载过程中都要调用一次具体的操作都会调用Operation，下面就分析一下中间的具体过程。<br>我们打开SDWebImage的文件夹可以到其中有一个SDWebImageOperation的类，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)cancel;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><br>其中我们使用NSOpation的子类来完成具体图片下载的过程，这个类就是SDWebImageDownloaderOperation。在SDWebImageDownloaderOperation类中继承NSOperation的类而且实现SDWebImageOperation的cancel的取消协议。除了继承而来的方法，该类只向外暴露了一个方法，即上面所用到的初始化方法initWithRequest:options:pregress:completed:cancelled:。</p>
<p>对于图片的下载，SDWebImageDownloaderOperation完全依赖于URL加载系统中的NSURLConnection类（并未使用iOS7以后的NSURLSession类）。我们先来分析一下SDWebImageDownloaderOperation类中对于图片实际数据的下载处理，即NSURLConnection各代理方法的实现。</p>
<p>首先，SDWebImageDownloaderOperation在Extention中采用了NSURLConnectionDataDelegate协议，并实现了协议的以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">connection:didReceiveResponse:</span><br><span class="line">connection:didReceiveData:</span><br><span class="line">connectionDidFinishLoading:</span><br><span class="line">connection:didFailWithError:</span><br><span class="line">connection:willCacheResponse:</span><br><span class="line">connectionShouldUseCredentialStorage:</span><br><span class="line">connection:willSendRequestForAuthenticationChallenge:</span><br></pre></td></tr></table></figure>
<p>这些方法我们就不逐一分析了，就终点分析一下connection:didReceiveResponse:和connection:didReceiveData:两个方法。</p>
<p>connection:didReceiveResponse方法通过判断NSURLResponse的实际类型和状态码，对除304以外400以内的状态码反应。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//'304 Not Modified' is an exceptional one</span></span><br><span class="line"> <span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] ||([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &lt; <span class="number">400</span> &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span>  *)response) statusCode] != <span class="number">304</span>)) &#123;</span><br><span class="line">      <span class="built_in">NSInteger</span> expected = response.expectedContentLength &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)</span><br><span class="line">      response.expectedContentLength : <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">self</span>.expectedSize = expected;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</span><br><span class="line">         <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, expected);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.imageData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];</span><br><span class="line">  <span class="keyword">self</span>.response = response;</span><br><span class="line">  <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:</span><br><span class="line">      SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="built_in">NSUInteger</span> code = [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//This is the case when server returns '304 Not Modified'. It means that </span></span><br><span class="line">   remote image is not changed.</span><br><span class="line">   <span class="comment">//In case of 304 we need just cancel the operation and return cached image       </span></span><br><span class="line">   from the cache.</span><br><span class="line">   <span class="keyword">if</span> (code == <span class="number">304</span>) &#123;</span><br><span class="line">       [<span class="keyword">self</span> cancelInternal];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</span><br><span class="line">       <span class="keyword">self</span>.completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:</span><br><span class="line">       <span class="built_in">NSURLErrorDomain</span> code:[((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] </span><br><span class="line">       userInfo:<span class="literal">nil</span>], <span class="literal">YES</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">   [<span class="keyword">self</span> done];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>connection:didReceiveData:方法的主要任务是接受数据。每次接收到数据时，都会用现有的数据创建一个CGImageSourceRef对象以作处理。在首次获取到数据时（width+height==0）会从这些包含图像信息的数据中取出图像的长、宽、方向等信息以备使用。而后在图片下载完成之前，会使用CGImageSourceRef对象创建一个图像对象，经过缩放、解压缩操作后生成一个UIImage对象供完成回调使用。当然，在这个方法中还需要处理的就是进度信息。如果我们有设置进度回调的话，就调用进度回调以处理当前图片的下载进度。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.imageData appendData:data];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.completedBlock) &#123;</span><br><span class="line"><span class="comment">// The following code is from http://www.cocoaintheshell.com/2011/05/</span></span><br><span class="line">progressive-images-download-imageio/</span><br><span class="line"><span class="comment">// Thanks to the author @Nyx0uf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the total bytes downloaded </span></span><br><span class="line">     <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = <span class="keyword">self</span>.imageData.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the data source, we must pass ALL the data, not just the new bytes</span></span><br><span class="line">     <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span>.imageData, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (width + height == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">                <span class="built_in">NSInteger</span> orientationValue = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;height);</span><br><span class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;width);</span><br><span class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyOrientation);</span><br><span class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberNSIntegerType, &amp;orientationValue);</span><br><span class="line">                <span class="built_in">CFRelease</span>(properties);</span><br><span class="line"><span class="comment">// When we draw to Core Graphics, we lose orientation information,</span></span><br><span class="line"><span class="comment">// which means the image below born of initWithCGIImage will be</span></span><br><span class="line"><span class="comment">// oriented incorrectly sometimes. (Unlike the image born of initWithData</span></span><br><span class="line"><span class="comment">// in connectionDidFinishLoading.) So save it here and pass it on later.</span></span><br><span class="line"></span><br><span class="line">                orientation = [[<span class="keyword">self</span> class] orientationFromPropertyValue:(orientationValue == <span class="number">-1</span> ? <span class="number">1</span> : orientationValue)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; totalSize &lt; <span class="keyword">self</span>.expectedSize) &#123;</span><br><span class="line">            <span class="comment">// Create the image</span></span><br><span class="line">            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef TARGET_OS_IPHONE</span></span><br><span class="line">            <span class="comment">// Workaround for iOS anamorphic image</span></span><br><span class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</span><br><span class="line">                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);</span><br><span class="line">                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">                <span class="keyword">if</span> (bmContext) &#123;</span><br><span class="line">                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>)&#123;.origin.x = <span class="number">0.0</span>f, .origin.y = <span class="number">0.0</span>f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</span><br><span class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);</span><br><span class="line">                    <span class="built_in">CGContextRelease</span>(bmContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">                    partialImageRef = <span class="literal">nil</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</span><br><span class="line">                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:partialImageRef scale:<span class="number">1</span> orientation:orientation];</span><br><span class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</span><br><span class="line">                <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</span><br><span class="line">                    image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    image = scaledImage;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</span><br><span class="line">                        <span class="keyword">self</span>.completedBlock(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CFRelease</span>(imageSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们前面说过SDWebImageDownloaderOperation类是继承自NSOperation类。它没有简单的实现main方法，而是采用更加灵活的start方法，以便自己管理下载的状态。</p>
<p>在start方法中，创建了我们下载所使用的NSURLConnection对象，开启了图片的下载，同时抛出一个下载开始的通知。start方法的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line">            [<span class="keyword">self</span> reset];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></span><br><span class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</span><br><span class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">            <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sself) &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line">        <span class="keyword">self</span>.thread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.connection start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.connection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (floor(<span class="built_in">NSFoundationVersionNumber</span>) &lt;= <span class="built_in">NSFoundationVersionNumber_iOS_5_1</span>) &#123;</span><br><span class="line">            <span class="comment">// Make sure to run the runloop in our background thread so it can process downloaded data</span></span><br><span class="line">            <span class="comment">// Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span></span><br><span class="line">            <span class="comment">//       not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466)</span></span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.isFinished) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">            [<span class="keyword">self</span> connection:<span class="keyword">self</span>.connection didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@&#123;<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span>.request.URL&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;], <span class="literal">YES</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></span><br><span class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</span><br><span class="line">        <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</span><br><span class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下载完后或者是下载失败后都会停止当前调用的runloop，清楚链接随后就抛出下载停止的消息。<br>如果下载成功，则会处理完整的图片数据，对其进行适当的缩放与解压缩操作，以提供给完成回调使用。具体可参考-connectionDidFinishLoading:与-connection:didFailWithError:的实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们在上面的介绍可以看出在下载图片的过程中，每次下载图片都会调用NSOperation的函数进行处理，每次数据实际实现是使用NSURLConnection。我们把具体实现的线程放置在队列中进行执行操作。如果下载成功，则会处理完整的图片数据，对其进行适当的缩放与解压缩操作，以提供给完成回调使用。具体可参考-connectionDidFinishLoading:与-connection:didFailWithError:的实现。</p>
<p><a href="http://boilwater.github.io/2016/06/04/SDWebImage之图片缓存分析/" target="_blank" rel="external">下一节我们将讲述如何对下载的图片进行缓存处理</a>;</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/06/03/SDWebImage/" data-id="cj2ev9rno000j9m42u0sj0z72" class="article-share-link">分享到</a><div class="tags"><a href="/tags/三方框架解析/">三方框架解析</a></div><div class="post-nav"><a href="/2016/06/04/SDWebImage之图片缓存分析/" class="pre">SDWebImage之图片缓存处理</a><a href="/2016/06/02/IOS面试梳理&amp;自己理解&amp;详细资料库/" class="next">IOS面试&amp;自己理解&amp;详细资料库</a></div><div id="disqus_thread"><script>var disqus_shortname = 'JackJin## Your disqus_shortname, e.g. username';
var disqus_identifier = '2016/06/03/SDWebImage/';
var disqus_title = 'SDWebImage之图片下载';
var disqus_url = 'http://yoursite.com/2016/06/03/SDWebImage/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//JackJin## Your disqus_shortname, e.g. username.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/第三方框架/">第三方框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-图层-动画/">视图&图层&动画</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/IOS/" style="font-size: 15px;">IOS</a> <a href="/tags/IOS基础知识/" style="font-size: 15px;">IOS基础知识</a> <a href="/tags/三方框架解析/" style="font-size: 15px;">三方框架解析</a> <a href="/tags/图片视频/" style="font-size: 15px;">图片视频</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/视频心得/" style="font-size: 15px;">视频心得</a> <a href="/tags/博客之初/" style="font-size: 15px;">博客之初</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/13/APP控件在屏幕上显示/">APP控件在屏幕上显示</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/09/IOS响应者链/">IOS整体框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/16/两周感悟~广州/">广州~两周感悟</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/UIView&CALayer&Core Animation~1/">UIView & CALayer& Core Animation ~ （UIView 和 CALayer）（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/UIView&CALayer&Core Animation-总体/">UIView&CALayer&Core Animation~开篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/15/IOS 10/">IOS 10.0</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最新评论</i></div><script type="text/javascript" src="//JackJin## Your disqus_shortname, e.g. username.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="https://github.com/boilWater" title="Github" target="_blank">Github</a><ul></ul><a href="http://weibo.com/u/2815612403?is_all=1" title="微博" target="_blank">微博</a><ul></ul><a href="http://www.jianshu.com/users/c48ed5ae3925/latest_articles" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">JackJin's 博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
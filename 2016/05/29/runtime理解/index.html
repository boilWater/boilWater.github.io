<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>runtime理解 | JackJin's 博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">runtime理解</h1><a id="logo" href="/.">JackJin's 博客</a><p class="description">一位脚踏实地，拥有梦想的90后，想要一直努力追上你！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">runtime理解</h1><div class="post-meta">May 29, 2016<span> | </span><span class="category"><a href="/categories/IOS/">IOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/05/29/runtime理解/" href="/2016/05/29/runtime理解/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime简介"><span class="toc-number">1.</span> <span class="toc-text">runtime简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#看其中一种实现方式"><span class="toc-number">2.</span> <span class="toc-text">看其中一种实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime动态操作"><span class="toc-number">3.</span> <span class="toc-text">runtime动态操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#获取类的对象名"><span class="toc-number">3.0.1.</span> <span class="toc-text">获取类的对象名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#获取类的实例变量和属性"><span class="toc-number">3.0.2.</span> <span class="toc-text">获取类的实例变量和属性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#动态的添加方法"><span class="toc-number">3.0.3.</span> <span class="toc-text">动态的添加方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#runtime使用API的介绍："><span class="toc-number">3.1.</span> <span class="toc-text">runtime使用API的介绍：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息传送机制"><span class="toc-number">4.</span> <span class="toc-text">消息传送机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#消息转发机制具体实现"><span class="toc-number">4.1.</span> <span class="toc-text">消息转发机制具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1动态解析方法"><span class="toc-number">4.1.1.</span> <span class="toc-text">1动态解析方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2备援接收到"><span class="toc-number">4.1.2.</span> <span class="toc-text">2备援接收到</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3完整的消息传递"><span class="toc-number">4.1.3.</span> <span class="toc-text">3完整的消息传递</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#如果方法调用失败"><span class="toc-number">4.1.4.</span> <span class="toc-text">如果方法调用失败</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#参考来之："><span class="toc-number">4.1.5.</span> <span class="toc-text">参考来之：</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>网上其实有很多关于讲述runtime的学习资料，也是站在巨人肩上看的更远。写这篇文章也是对于其他人借鉴和翻阅源码，向源码寻求解释吧。</p>
<a id="more"></a>
<p>网上其实有很多关于讲述runtime的学习资料，也是站在巨人肩上看的更远。写这篇文章也是对于其他人借鉴和翻阅源码，向源码寻求解释吧。</p>
<h4 id="runtime简介"><a href="#runtime简介" class="headerlink" title="runtime简介"></a>runtime简介</h4><p>Objc被我们成为动态语言，换句话说就是把我们平时看到一些关键方法由编译连接推迟到运行时执行。Objc底层是基于C/C++的编译语言，在C/C++项目运行过程中编译、链接生成可执行文件。而Objc语言是在执行过程中进行编译源码，这也是Objc中自己特色：动态类型，动态绑定和动态加载。获runtime的源码点击<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418" target="_blank" rel="external">这里</a></p>
<p>这里我们主要探究runtime.h和message.h两个文件夹中一些使用方法。<br>下面列出runtime.h文件中代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;  <span class="comment">//代表类定义当中的使用方法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;  <span class="comment">//代表类定义中实例变量和属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category; <span class="comment">//代表添加成员函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t; <span class="comment">//声明的属性</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    <span class="meta">#if !__OBJC2__</span></span><br><span class="line"></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">     <span class="meta">#endif&#125; </span></span><br><span class="line">    OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>
<h4 id="看其中一种实现方式"><a href="#看其中一种实现方式" class="headerlink" title="看其中一种实现方式"></a>看其中一种实现方式</h4><p>其中我们就以类中struct objc_ivar_list *ivars ,为例来看是怎样实现<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">可以看出实例变量和属性是存放时一个struct的list的数组中，其中包括list的数目、所占空间和基本储存objc_ivar。&lt;/br&gt;</span><br><span class="line">上面objc_ivar在runtime.h中形式：</span><br><span class="line">typedef struct objc_ivar Ivar;</span><br><span class="line">objc_ivar中实例变量储存方式：</span><br><span class="line">struct objc_ivar &#123;</span><br><span class="line"></span><br><span class="line">    char *ivar_name                       OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                       OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                      OBJC2_UNAVAILABLE;</span><br><span class="line">    #indef _LP64_</span><br><span class="line">    int space                             OBJC2_UNAVAILABLE;</span><br><span class="line">    #endif</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出类的实例变量和属性经过runtime编译后是以struct的储存形式存在，并且单个实例变量保存其名字、类型、偏移量和储存空间。类中所有实例变量是以list类型进行储存。</p>
<blockquote>
<p>通过对runtime.h文件源码分析我们可以看出，在IOS程序运行过程中把我们类中元素编译为C/C++形式。且编译过程是一个动态过程，所以我们可以通过此方式对我们程序进行动态操作</p>
</blockquote>
<h4 id="runtime动态操作"><a href="#runtime动态操作" class="headerlink" title="runtime动态操作"></a>runtime动态操作</h4><ul>在动态编译过程中无论是属性、实例变量、成员函数、类方法的均可以操作，一下就以比较简单的进行讲解<br><li>获取类的对象名</li><br><li>获取类中成实例变量和属性</li><br><li>动态添加方法</li><br></ul>

<h6 id="获取类的对象名"><a href="#获取类的对象名" class="headerlink" title="获取类的对象名"></a>获取类的对象名</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Class *classes = objc_copyClassList(&amp;count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name = class_getName(classes[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出的内容可能出乎你的意料！</p>
<h6 id="获取类的实例变量和属性"><a href="#获取类的实例变量和属性" class="headerlink" title="获取类的实例变量和属性"></a>获取类的实例变量和属性</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = <span class="built_in">NSClassFromString</span>(<span class="string">@"Graduater"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Ivar *var = class_copyIvarList(clazz, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var[i]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我定义一个毕业生类，然后就可以打印出其中的函数实例变量和属性（不多记得要引入<objc runtime.h="">的头文件）；</objc></p>
<h6 id="动态的添加方法"><a href="#动态的添加方法" class="headerlink" title="动态的添加方法"></a>动态的添加方法</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> abc(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@hello"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Graduater</span></span></span><br><span class="line"></span><br><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="string">@"sihai"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, abc, <span class="string">"v@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在函数调用时执行下列：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Graduater *graduate = [[Graduater alloc] init];</span><br><span class="line"></span><br><span class="line">[graduate performSelector:<span class="keyword">@selector</span>(sihai) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><br>执行的结果可以条用我们添加的@select(abc)的方法。</p>
<h5 id="runtime使用API的介绍："><a href="#runtime使用API的介绍：" class="headerlink" title="runtime使用API的介绍："></a>runtime使用API的介绍：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName(Class cls) <span class="comment">//获取class的名字</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types)  <span class="comment">//增添实例变量</span></span><br><span class="line"></span><br><span class="line">objc_property_t  class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name) <span class="comment">//获取属性</span></span><br><span class="line"></span><br><span class="line">objc_property_t * class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount) <span class="comment">//获取属性列表</span></span><br><span class="line"></span><br><span class="line">Method class_getInstanceMethod(Class aClass, SEL aSelector) <span class="comment">//获取方法</span></span><br><span class="line"></span><br><span class="line">objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes) <span class="comment">//添加动态类</span></span><br></pre></td></tr></table></figure>
<p>除去上面我们列举其中极少数的调用实例，如果想了解更多点击<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418-CH1g-211911" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>在使用runtime过程，对于操作对象实行方法改善<br>对于对象进行相关操作一般以objc<em>开头<br>对于类的对象进行操作一般以class</em>开头<br>对于使用方法对象操作一般以method<em>开头<br>对于使用申明属性（property）一般是以property</em>开头<br>对于使用类成员变量一般使用ivar_开头</p>
</blockquote>
<h4 id="消息传送机制"><a href="#消息传送机制" class="headerlink" title="消息传送机制"></a>消息传送机制</h4><p>在IOS的一个类中我们调用方法使用也是比较多，如<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> method];</span><br></pre></td></tr></table></figure><br>但是在runtime编译过程中具体实现的方式是什么呢？<br>首先我们看先message.h中的源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic Messaging Primitives</span><br><span class="line"> * On some architectures, use objc_msgSend_stret for some struct return types.</span><br><span class="line"> * On some architectures, use objc_msgSend_fpret for some float return types.</span><br><span class="line"> * These functions must be cast to an appropriate function pointer type </span><br><span class="line"> * before being called. */</span></span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...);</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...);</span><br></pre></td></tr></table></figure><br>从上面的解释我们可以的出如果返回类型为float调用objc_msgSend_fpret，如果是数据结构返回使用objc_msgSend_stret。而我们讲解时使用 objc_msgSend(id self, SEL op, …)，就像我们上面的例子就会转化为objc_msgSend(self @select(method))，但是找到我们所使用的方法具体是怎么实现的？</p>
<h5 id="消息转发机制具体实现"><a href="#消息转发机制具体实现" class="headerlink" title="消息转发机制具体实现"></a>消息转发机制具体实现</h5><p>在动态添加方法过程中，我们使用如下方式：</p>
<h6 id="1动态解析方法"><a href="#1动态解析方法" class="headerlink" title="1动态解析方法"></a>1动态解析方法</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure>
<p>具体实例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="string">@"sihai"</span>])</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">   class_addMethod(<span class="keyword">self</span>, sel, abc, <span class="string">"v@:"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>从这里我们就可以看出在函数调用过程中runtime会根据SEl识别子进行寻找，在例子中我们有相应的识别可以查询，如果没有相应的识别子呢？</p>
<blockquote>
<p>在系统中如果在查找过程中没有找到相应的选择子，就会调用上面的函数<br>+(BOOL)resolveInstanceMethod:(SEL)sel；生成实例方法，如上面例子（添加相应的实例方法可以实现，就跳转方法实现）。把添加方法放入到缓存中，可以供我们进行下次的调用</p>
</blockquote>
<p>如果上面我们找到相应的识别子，就会进行第二次对选择子进行相关的处理。</p>
<h6 id="2备援接收到"><a href="#2备援接收到" class="headerlink" title="2备援接收到"></a>2备援接收到</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line">具体实例如下：</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"sihai"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统会把选择子作为参数，返回给我们一个选择子对象。运行的系统就会对相关方法实例进行查找，如果找到相关方法就实行，找不到就结束转发。</p>
<h6 id="3完整的消息传递"><a href="#3完整的消息传递" class="headerlink" title="3完整的消息传递"></a>3完整的消息传递</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br><span class="line">实现的具体方法如下：</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"sihai"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line"></span><br><span class="line">        anInvocation.selector = <span class="keyword">@selector</span>(fly);</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上面2步骤中返回依然是nil，也会执行完整的消息传输消息机制。在该方法中我们可以改变其目标，然后运行系统就会根据改变的目标，在其目标中查询实现方法别调用。当然也可以进行修改选择子。</p>
<h6 id="如果方法调用失败"><a href="#如果方法调用失败" class="headerlink" title="如果方法调用失败"></a>如果方法调用失败</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>通过对于[self method];方法的实现过程的进行探究我们我们可以了解到在消息传递过程是如何实现的，而且我们可以更具我们需求对其中的方法进行相应的而修改。</p>
<blockquote>
<p>runtime是Objc语言特性，本人通过对于的研究理解是：通过runtime我们可以等到我们类中所有元素的资料信息，可以使用期同工的API对类进行我们想到达到的目的；在我们调试过程中也可以通过打印来简化我们调试信息；最棒的就是我们可以了解程序运行过程可以在开发中使我们更加得心应手。</p>
</blockquote>
<p><br></p>
<h6 id="参考来之："><a href="#参考来之：" class="headerlink" title="参考来之："></a>参考来之：</h6><p><a href="http://www.cocoachina.com/ios/20151015/13769.html" target="_blank" rel="external">Runtime初涉之消息转发</a><br><br><br><a href="http://www.cocoachina.com/ios/20150901/13173.html" target="_blank" rel="external">学习runtime的理解和心得</a><br><br><br><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418-CH1g-88778" target="_blank" rel="external">runtime 源码</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/05/29/runtime理解/" data-id="ciowxss0i000e3i2awj8pexwi" class="article-share-link">Share</a><div class="tags"><a href="/tags/IOS/">IOS</a></div><div class="post-nav"><a href="/2016/05/29/IOS整体框架/" class="pre">IOS整体框架</a><a href="/2016/05/29/Fastlane讲解/" class="next">Fastlane讲解</a></div><div id="disqus_thread"><script>var disqus_shortname = 'JackJin## Your disqus_shortname, e.g. username';
var disqus_identifier = '2016/05/29/runtime理解/';
var disqus_title = 'runtime理解';
var disqus_url = 'http://yoursite.com/2016/05/29/runtime理解/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//JackJin## Your disqus_shortname, e.g. username.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/IOS/" style="font-size: 15px;">IOS</a> <a href="/tags/图片视频/" style="font-size: 15px;">图片视频</a> <a href="/tags/视频心得/" style="font-size: 15px;">视频心得</a> <a href="/tags/博客之初/" style="font-size: 15px;">博客之初</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/30/UIView&CALayer/">UIView & CALayer & Core Animation</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/29/cocoaPods使用和静态库的建立/">cocoaPods使用和静态库的建立</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/29/IOS的永久话储存/">IOS的永久话储存</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/29/IOS整体框架/">IOS整体框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/29/runtime理解/">runtime理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/29/Fastlane讲解/">Fastlane讲解</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最新评论</i></div><script type="text/javascript" src="//JackJin## Your disqus_shortname, e.g. username.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="https://github.com/boilWater" title="Github" target="_blank">Github</a><ul></ul><a href="http://weibo.com/u/2815612403?is_all=1" title="微博" target="_blank">微博</a><ul></ul><a href="http://www.jianshu.com/users/c48ed5ae3925/latest_articles" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">JackJin's 博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
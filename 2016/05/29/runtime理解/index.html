<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> runtime理解 · JackJin's 博客</title><meta name="description" content="runtime理解 - JackJin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">runtime理解</h1><div class="post-info">May 29, 2016</div><div class="post-content"><p><link rel="stylesheet" href="/Users/liangbai/highlight/styles/xcode.css">  </p>
<script src="/Users/liangbai/highlight/highlight.pack.js"></script>  
<script>hljs.initHighlightingOnLoad();</script>



<p>网上其实有很多关于讲述runtime的学习资料，也是站在巨人肩上看的更远。写这篇文章也是对于其他人借鉴和翻阅源码，向源码寻求解释吧。</p>
<p>####runtime简介<br>Objc被我们成为动态语言，换句话说就是把我们平时看到一些关键方法由编译连接推迟到运行时执行。Objc底层是基于C/C++的编译语言，在C/C++项目运行过程中编译、链接生成可执行文件。而Objc语言是在执行过程中进行编译源码，这也是Objc中自己特色：动态类型，动态绑定和动态加载。获runtime的源码点击<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418" target="_blank" rel="external">这里</a></p>
<p>这里我们主要探究runtime.h和message.h两个文件夹中一些使用方法。<br>下面列出runtime.h文件中代码：</p>
<p><pre><br><code><br>typedef struct objc_method <em>Method;  //代表类定义当中的使用方法<br></em></code><br><code><br>typedef struct objc_ivar Ivar;  //代表类定义中实例变量和属性<br></code><br><code><br>typedef struct objc_category <em>Category; //代表添加成员函数<br></em></code><br><code><br>typedef struct objc_property objc_property_t; //声明的属性<br></code><br><code><br>struct objc_class {<br>    Class isa;</code></pre></p>
<p>#if !<strong>OBJC2</strong></p>
<pre><code>Class super_class                                        OBJC2_UNAVAILABLE;
const char *name                                         OBJC2_UNAVAILABLE;
long version                                             OBJC2_UNAVAILABLE;
long info                                                OBJC2_UNAVAILABLE;
long instance_size                                       OBJC2_UNAVAILABLE;
struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
</code></pre><p>#endif<br>}<br>OBJC2_UNAVAILABLE;<br><br></p>
<p>####看其中一种实现方式</p>
<p>其中我们就以类中struct objc_ivar_list *ivars ,为例来看是怎样实现</p>
<p><pre><br><code><br>struct objc_ivar_list {</code></pre></p>
<pre><code>int ivar_count                                           OBJC2_UNAVAILABLE;
</code></pre><p>#ifdef <strong>LP64</strong><br>    int space                                                OBJC2_UNAVAILABLE;</p>
<p>#endif<br>    /<em> variable length structure </em>/<br>    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;<br>}                                                            OBJC2_UNAVAILABLE;<br><br>可以看出实例变量和属性是存放时一个struct的list的数组中，其中包括list的数目、所占空间和基本储存objc_ivar。<br><br>上面objc_ivar在runtime.h中形式：<pre><br><code><br>typedef struct objc_ivar Ivar;<br></code><br></pre>objc_ivar中实例变量储存方式：<pre><br>struct objc_ivar {<br><code><br>    char <em>ivar_name                       OBJC2_UNAVAILABLE;<br>    char </em>ivar_type                       OBJC2_UNAVAILABLE;<br>    int ivar_offset                      OBJC2_UNAVAILABLE;</code></pre></p>
<pre><code>#indef _LP64_
int space                             OBJC2_UNAVAILABLE;
#endif
</code></pre><p><br>}从上面可以看出类的实例变量和属性经过runtime编译后是以struct的储存形式存在，并且单个实例变量保存其名字、类型、偏移量和储存空间。类中所有实例变量是以list类型进行储存。</p>
<blockquote>
<p>通过对runtime.h文件源码分析我们可以看出，在IOS程序运行过程中把我们类中元素编译为C/C++形式。且编译过程是一个动态过程，所以我们可以通过此方式对我们程序进行动态操作</p>
</blockquote>
<p>####runtime动态操作</p>
<ul>在动态编译过程中无论是属性、实例变量、成员函数、类方法的均可以操作，一下就以比较简单的进行讲解<br><li>获取类的对象名</li><br><li>获取类中成实例变量和属性</li><br><li>动态添加方法</li><br></ul>

<p>######获取类的对象名</p>
<p><pre><br><code><br>unsigned int count = 0;</code></pre></p>
<p>Class *classes = objc_copyClassList(&amp;count);</p>
<p>for (int i = 0; i &lt; count; i++) {</p>
<p>const char *name = class_getName(classes[i]);</p>
<p>NSLog(@”%s”, name);<br>}<br>打印出的内容可能出乎你的意料！</p>
<p>######获取类的实例变量和属性</p>
<p><pre><br><code><br>Class clazz = NSClassFromString(@”Graduater”);</code></pre></p>
<pre><code>unsigned int count = 0;

Ivar *var = class_copyIvarList(clazz, &amp;count);

for (int i = 0; i &lt; count; i++) {
    const char *name = ivar_getName(var[i]);
    NSLog(@&quot;%s&quot;, name);
}
</code></pre><p>我定义一个毕业生类，然后就可以打印出其中的函数实例变量和属性（不多记得要引入<objc runtime.h="">的头文件）；</objc></p>
<p>######动态的添加方法</p>
<p><pre><br><code></code></pre></p>
<p>#import <objc runtime.h=""></objc></p>
<p>void abc(id self, SEL _cmd){</p>
<pre><code>NSLog(@&quot;%@hello&quot;, self);
</code></pre><p>}</p>
<p>@implementation Graduater</p>
<p>+(BOOL)resolveInstanceMethod:(SEL)sel{</p>
<pre><code>if ([NSStringFromSelector(sel) isEqualToString:@&quot;sihai&quot;]) {
    class_addMethod(self, sel, abc, &quot;v@:&quot;);
}
return YES;
</code></pre><p>}<br><br>然后在函数调用时执行下列：</p>
<p><pre><br><code><br> Graduater *graduate = [[Graduater alloc] init];</code></pre></p>
<p> [graduate performSelector:@selector(sihai) withObject:nil];<br>执行的结果可以条用我们添加的@select(abc)的方法。</p>
<p>#####runtime使用API的介绍：</p>
<p><pre><br><code><br>const char * class_getName(Class cls) //获取class的名字</code></pre></p>
<p>BOOL class_addIvar(Class cls, const char <em>name, size_t size, uint8_t alignment, const char </em>types)  //增添实例变量</p>
<p>objc_property_t  class_getProperty(Class cls, const char *name) //获取属性</p>
<p>objc_property_t <em> class_copyPropertyList(Class cls, unsigned int </em>outCount) //获取属性列表</p>
<p>Method class_getInstanceMethod(Class aClass, SEL aSelector) //获取方法</p>
<p>objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes) //添加动态类<br>除去上面我们列举其中极少数的调用实例，如果想了解更多点击<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418-CH1g-211911" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>在使用runtime过程，对于操作对象实行方法改善<br>对于对象进行相关操作一般以objc<em>开头<br>对于类的对象进行操作一般以class</em>开头<br>对于使用方法对象操作一般以method<em>开头<br>对于使用申明属性（property）一般是以property</em>开头<br>对于使用类成员变量一般使用ivar_开头</p>
</blockquote>
<p>####消息传送机制<br>在IOS的一个类中我们调用方法使用也是比较多，如</p>
<p><pre><br>[self method];<br></pre>但是在runtime编译过程中具体实现的方式是什么呢？<br>首先我们看先message.h中的源码</p>
<p><pre><br><code><br>/* Basic Messaging Primitives</code></pre></p>
<ul>
<li>On some architectures, use objc_msgSend_stret for some struct return types.</li>
<li>On some architectures, use objc_msgSend_fpret for some float return types.</li>
<li>These functions must be cast to an appropriate function pointer type </li>
<li>before being called. */</li>
</ul>
<p>OBJC_EXPORT id objc_msgSend(id self, SEL op, …);</p>
<p>OBJC_EXPORT id objc_msgSendSuper(struct objc_super *super, SEL op, …);<br>从上面的解释我们可以的出如果返回类型为float调用objc_msgSend_fpret，如果是数据结构返回使用objc_msgSend_stret。而我们讲解时使用 objc_msgSend(id self, SEL op, …)，就像我们上面的例子就会转化为objc_msgSend(self @select(method))，但是找到我们所使用的方法具体是怎么实现的？</p>
<p>#####消息转发机制具体实现<br>在动态添加方法过程中，我们使用如下方式：</p>
<p>######1动态解析方法</p>
<p><pre><br><code><br>+(BOOL)resolveInstanceMethod:(SEL)sel;<br></code><br></pre>具体实例如下：</p>
<p><pre><br><code><br>+(BOOL)resolveInstanceMethod:(SEL)sel{</code></pre></p>
<p>if ([NSStringFromSelector(sel) isEqualToString:@”sihai”])<br> {</p>
<p>   class_addMethod(self, sel, abc, “v@:”);</p>
<p>   return YES;</p>
<p>}</p>
<p>   return NO;</p>
<p>}<br>从这里我们就可以看出在函数调用过程中runtime会根据SEl识别子进行寻找，在例子中我们有相应的识别可以查询，如果没有相应的识别子呢？</p>
<blockquote>
<p>在系统中如果在查找过程中没有找到相应的选择子，就会调用上面的函数<br>+(BOOL)resolveInstanceMethod:(SEL)sel；生成实例方法，如上面例子（添加相应的实例方法可以实现，就跳转方法实现）。把添加方法放入到缓存中，可以供我们进行下次的调用</p>
</blockquote>
<p>如果上面我们找到相应的识别子，就会进行第二次对选择子进行相关的处理。</p>
<p>######2备援接收到</p>
<p><pre><br><code><br>-(id)forwardingTargetForSelector:(SEL)aSelector;<br></code><br></pre>具体实例如下：</p>
<p><pre><br><code><br>-(id)forwardingTargetForSelector:(SEL)aSelector{</code></pre></p>
<pre><code>if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;sihai&quot;]) {
    return self;
}
    return [super forwardingTargetForSelector:aSelector];
</code></pre><p>}<br>系统会把选择子作为参数，返回给我们一个选择子对象。运行的系统就会对相关方法实例进行查找，如果找到相关方法就实行，找不到就结束转发。</p>
<p>######3完整的消息传递</p>
<p><pre><br><code><br>-(void)forwardInvocation:(NSInvocation *)anInvocation;<br></code><br></pre>实现的具体方法如下：</p>
<p><pre><br><code><br>-(NSMethodSignature*)methodSignatureForSelector:(SEL)aSelector{</code></pre></p>
<pre><code>if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;sihai&quot;]) {
    return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];
}
return [super methodSignatureForSelector:aSelector];
</code></pre><p>}</p>
<p>-(void)forwardInvocation:(NSInvocation *)anInvocation{</p>
<pre><code>anInvocation.selector = @selector(fly);
[anInvocation invokeWithTarget:self];
</code></pre><p>}<br><br>如果上面2步骤中返回依然是nil，也会执行完整的消息传输消息机制。在该方法中我们可以改变其目标，然后运行系统就会根据改变的目标，在其目标中查询实现方法别调用。当然也可以进行修改选择子。</p>
<p>######如果方法调用失败</p>
<p><pre><br><code><br>-(void)doesNotRecognizeSelector:(SEL)aSelector;<br></code><br></pre>通过对于[self method];方法的实现过程的进行探究我们我们可以了解到在消息传递过程是如何实现的，而且我们可以更具我们需求对其中的方法进行相应的而修改。</p>
<blockquote>
<p>runtime是Objc语言特性，本人通过对于的研究理解是：通过runtime我们可以等到我们类中所有元素的资料信息，可以使用期同工的API对类进行我们想到达到的目的；在我们调试过程中也可以通过打印来简化我们调试信息；最棒的就是我们可以了解程序运行过程可以在开发中使我们更加得心应手。</p>
</blockquote>
<p><br></p>
<p>######参考来之：</p>
<p><a href="http://www.cocoachina.com/ios/20151015/13769.html" target="_blank" rel="external">Runtime初涉之消息转发</a><br><br><br><a href="http://www.cocoachina.com/ios/20150901/13173.html" target="_blank" rel="external">学习runtime的理解和心得</a><br><br><br><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418-CH1g-88778" target="_blank" rel="external">runtime 源码</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/05/29/Fastlane讲解/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">JackJin</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>
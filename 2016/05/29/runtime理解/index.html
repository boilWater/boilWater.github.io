<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>runtime理解 | JackJin's 博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">runtime理解</h1><a id="logo" href="/.">JackJin's 博客</a><p class="description">一位脚踏实地，拥有梦想的90后，想要一直努力追上你！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">runtime理解</h1><div class="post-meta">May 29, 2016<span> | </span><span class="category"><a href="/categories/IOS/">IOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/05/29/runtime理解/" href="/2016/05/29/runtime理解/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#runtime简介"><span class="toc-number">1.</span> <span class="toc-text">runtime简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#看其中一种实现方式"><span class="toc-number">2.</span> <span class="toc-text">看其中一种实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runtime动态操作"><span class="toc-number">3.</span> <span class="toc-text">runtime动态操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取类的对象名"><span class="toc-number">4.</span> <span class="toc-text">获取类的对象名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取类的实例变量和属性"><span class="toc-number">5.</span> <span class="toc-text">获取类的实例变量和属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态的添加方法"><span class="toc-number">6.</span> <span class="toc-text">动态的添加方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runtime使用API的介绍："><span class="toc-number">7.</span> <span class="toc-text">runtime使用API的介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息传送机制"><span class="toc-number">8.</span> <span class="toc-text">消息传送机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息转发机制具体实现"><span class="toc-number">9.</span> <span class="toc-text">消息转发机制具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1动态解析方法"><span class="toc-number">10.</span> <span class="toc-text">1动态解析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2备援接收到"><span class="toc-number">11.</span> <span class="toc-text">2备援接收到</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3完整的消息传递"><span class="toc-number">12.</span> <span class="toc-text">3完整的消息传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果方法调用失败"><span class="toc-number">13.</span> <span class="toc-text">如果方法调用失败</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考来之："><span class="toc-number">14.</span> <span class="toc-text">参考来之：</span></a></li></ol></div></div><div class="post-content"><p>网上其实有很多关于讲述runtime的学习资料，也是站在巨人肩上看的更远。写这篇文章也是对于其他人借鉴和翻阅源码，向源码寻求解释吧。<br><br>无意间看到一份关于runtime的博客，感觉写的挺不错的就耐心的看下。看后发现自己对runtime的理解还是比较浅，就决定对自己博客进行重新修改。</p>
<div style="color:#008B8B"><br><p>随便在这里抛出一个问题：假如我们程序员自己是系统我们怎么执行程序呢？当然换个高级点的说法，如果我们是系统设计者我们想要runtime怎么运行？</p><br></div>

<p>在介绍runtime之前我现在这里给大家梳理一下我们在Objc类中可能见到的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-成员变量、成员属性：&lt;br&gt;</span><br><span class="line">-数据成员：&lt;/br&gt;</span><br><span class="line">-协议实现：&lt;/br&gt;</span><br></pre></td></tr></table></figure>
<h3 id="runtime简介"><a href="#runtime简介" class="headerlink" title="runtime简介"></a>runtime简介</h3><p>Objc被我们成为动态语言，换句话说就是把我们平时看到一些关键方法由编译连接推迟到运行时执行。Objc底层是基于C/C++的编译语言，在C/C++项目运行过程中链接、编译生成可执行文件。而Objc语言是在执行过程中进行编译源码，生成我们熟悉的C/C++后面最终生成机器可以识别的汇编语言。Objc中有三大自己特色：动态类型，动态绑定和动态加载。<br><br>获runtime的源码点击<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418" target="_blank" rel="external">这里</a></p>
<p>这里我们主要探究runtime.h和message.h两个文件夹中一些使用方法。<br>下面列出runtime.h文件中代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;  <span class="comment">//代表类定义当中的使用方法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;  <span class="comment">//代表类定义中实例变量和属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category; <span class="comment">//代表添加成员函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t; <span class="comment">//声明的属性</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    <span class="meta">#if !__OBJC2__</span></span><br><span class="line"></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;<span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;<span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;<span class="comment">//类的版本信心，默认的情况下是0</span></span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;<span class="comment">//类信息</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;<span class="comment">//类的实例变量的大小</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;<span class="comment">//类成员变量的列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;<span class="comment">//类的方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;<span class="comment">//方法缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;<span class="comment">//类的协议列表</span></span><br><span class="line">     <span class="meta">#endif&#125; </span></span><br><span class="line">    OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<h3 id="看其中一种实现方式"><a href="#看其中一种实现方式" class="headerlink" title="看其中一种实现方式"></a>看其中一种实现方式</h3><p>其中我们就以类中struct objc_ivar_list *ivars ,为例来看是怎样实现<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;<span class="comment">//成员列表的数量</span></span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;<span class="comment">//成员列表的空间</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>
<p>可以看出实例变量和属性是存放时一个struct的list的数组中，其中包括list的数目、所占空间和基本储存objc_ivar。<br></p>
<p>上面objc_ivar在runtime.h中形式：<br>typedef struct objc_ivar Ivar;<br>objc_ivar中实例变量储存方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *ivar_name                       OBJC2_UNAVAILABLE;<span class="comment">//成员的名字</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_type                       OBJC2_UNAVAILABLE;<span class="comment">//成员数据的类型</span></span><br><span class="line">    <span class="keyword">int</span> ivar_offset                      OBJC2_UNAVAILABLE;<span class="comment">//成员的偏移量</span></span><br><span class="line">    <span class="meta">#indef _LP64_</span></span><br><span class="line">    <span class="keyword">int</span> space                             OBJC2_UNAVAILABLE;<span class="comment">//成员变量所占空间</span></span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出类的实例变量和属性经过runtime编译后是以struct的储存形式存在，并且单个实例变量保存其名字、类型、偏移量和储存空间。类中所有实例变量是以list类型进行储存。</p>
<blockquote>
<p>通过对runtime.h文件源码分析我们可以看出，在IOS程序运行过程中把我们类编译为C/C++形式。且编译过程是一个动态过程，所以我们可以通过此方式对我们程序进行动态操作</p>
</blockquote>
<h3 id="runtime动态操作"><a href="#runtime动态操作" class="headerlink" title="runtime动态操作"></a>runtime动态操作</h3><ul>在动态编译过程中无论是属性、实例变量、成员函数、类方法的均可以操作，一下就以比较简单的进行讲解<br><li>获取类的对象名</li><br><li>获取类中成实例变量和属性</li><br><li>动态添加方法</li><br></ul>

<h3 id="获取类的对象名"><a href="#获取类的对象名" class="headerlink" title="获取类的对象名"></a>获取类的对象名</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Class *classes = objc_copyClassList(&amp;count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name = class_getName(classes[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出的内容可能出乎你的意料！</p>
<h3 id="获取类的实例变量和属性"><a href="#获取类的实例变量和属性" class="headerlink" title="获取类的实例变量和属性"></a>获取类的实例变量和属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = <span class="built_in">NSClassFromString</span>(<span class="string">@"Graduater"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Ivar *var = class_copyIvarList(clazz, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var[i]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我定义一个毕业生类，然后就可以打印出其中的函数实例变量和属性（不多记得要引入<objc runtime.h="">的头文件）；</objc></p>
<h3 id="动态的添加方法"><a href="#动态的添加方法" class="headerlink" title="动态的添加方法"></a>动态的添加方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> abc(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@hello"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Graduater</span></span></span><br><span class="line"></span><br><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="string">@"sihai"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, abc, <span class="string">"v@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在函数调用时执行下列：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Graduater *graduate = [[Graduater alloc] init];</span><br><span class="line"></span><br><span class="line">[graduate performSelector:<span class="keyword">@selector</span>(sihai) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>执行的结果可以条用我们添加的@select(abc)的方法。</p>
<h3 id="runtime使用API的介绍："><a href="#runtime使用API的介绍：" class="headerlink" title="runtime使用API的介绍："></a>runtime使用API的介绍：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName(Class cls) <span class="comment">//获取class的名字</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types)  <span class="comment">//增添实例变量</span></span><br><span class="line"></span><br><span class="line">objc_property_t  class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name) <span class="comment">//获取属性</span></span><br><span class="line"></span><br><span class="line">objc_property_t * class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount) <span class="comment">//获取属性列表</span></span><br><span class="line"></span><br><span class="line">Method class_getInstanceMethod(Class aClass, SEL aSelector) <span class="comment">//获取方法</span></span><br><span class="line"></span><br><span class="line">objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes) <span class="comment">//添加动态类</span></span><br></pre></td></tr></table></figure>
<p>除去上面我们列举其中极少数的调用实例，如果想了解更多点击<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418-CH1g-211911" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>在使用runtime过程，对于操作对象实行方法改善<br>对于对象进行相关操作一般以objc<em>开头<br>对于类的对象进行操作一般以class</em>开头<br>对于使用方法对象操作一般以method<em>开头<br>对于使用申明属性（property）一般是以property</em>开头<br>对于使用类成员变量一般使用ivar_开头</p>
</blockquote>
<h3 id="消息传送机制"><a href="#消息传送机制" class="headerlink" title="消息传送机制"></a>消息传送机制</h3><p>在IOS的一个类中我们调用方法使用也是比较多，如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> method];</span><br></pre></td></tr></table></figure>
<p>但是在runtime编译过程中具体实现的方式是什么呢？<br>首先我们看先message.h中的源码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic Messaging Primitives</span><br><span class="line"> * On some architectures, use objc_msgSend_stret for some struct return types.</span><br><span class="line"> * On some architectures, use objc_msgSend_fpret for some float return types.</span><br><span class="line"> * These functions must be cast to an appropriate function pointer type </span><br><span class="line"> * before being called. */</span></span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...);</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...);</span><br></pre></td></tr></table></figure>
<p>从上面的解释我们可以的出如果返回类型为float调用objc_msgSend_fpret，如果是数据结构返回使用objc_msgSend_stret。而我们讲解时使用 objc_msgSend(id self, SEL op, …)，就像我们上面的例子就会转化为objc_msgSend(self @select(method))，但是找到我们所使用的方法具体是怎么实现的？</p>
<div style="color:#008B8B"><br><p>在此地方我就将添加上面看到的关于objc_msgSend,objc_msgSendSuper,SEL</p><br></div>

<hr>
<p>数据类型：<br>（1）SEL:<br>     SEL又叫做选择器，表示一个@selector的指针，映射方法的名字。在Objc编译的过程中通过每个方法的名字和参数是生成的唯一的标示（此标示是int的类型），我们把这个标示称作为SEL。<br><br>     SEl的作用是作为IMP（关于IMP的具体说明会在下面展示）的key存在，存储在NSSet的中，这样可以方便我们使用hash的快速查找。SEL使我们查找IMP（指向实现函数的指针）key，如果SEL可以相同的话我们调用函数就会发生错误。所以SEL是不可以重复的，方法也是不可以重复的。这也就是我们在Objc开发过程中在同一个类中不可以使用同名的函数~~~此处和C++支持重载有很大区别。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure><br>虽说在runtime.h中没有显示objc_selector结构体类型，但是作为程序员的我们可以找到方法进行验证，使用log打印SEL试下？<br><br>（2）IMP:<br>      IMP上面讲到IMP把SEL作为key值，IMP说白啦就是指向我们方法的指针，也就是我们条用具体函数方法的入口。</p>
<figure class="highlight plain"><figcaption><span>lang: objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedefine id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>
<p>（3）Method<br>       Method:上面我们在类的Struct的结构中可以看出Method是放置我们使用的方法，也是我们使用SEL和IMP的一个具体的绑定。通过使用SEL来找到对应的IMP进而实现我们方法的具体调用。下面看代码：</p>
<figure class="highlight plain"><figcaption><span>lang: objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名</span><br><span class="line">    char *method_types                  OBJC2_UNAVAILABLE; // 参数类型</span><br><span class="line">    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们看下在类中方法具体实现的形式：</p>
<figure class="highlight plain"><figcaption><span>lang: objc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line">    int method_count                                                 OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                              OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）方法缓存<br>我们在调用方法的过程其实是Lazy调用的过程，方法在第一次调用加载后会放到缓存池中。objc程序启动后，需要进行类的初始化、调用方法时的cache初始化，再发送消息的时候就直接走缓存。<br><br>下面我会对方法缓存做详细的解释。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="comment">// 缓存bucket的总数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际缓存bucket的总数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">// 指向Method数据结构指针的数组</span></span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="消息转发机制具体实现"><a href="#消息转发机制具体实现" class="headerlink" title="消息转发机制具体实现"></a>消息转发机制具体实现</h3><p>在动态添加方法过程中，我们使用如下方式：</p>
<h3 id="1动态解析方法"><a href="#1动态解析方法" class="headerlink" title="1动态解析方法"></a>1动态解析方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure>
<p>具体实例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="string">@"sihai"</span>])</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">   class_addMethod(<span class="keyword">self</span>, sel, abc, <span class="string">"v@:"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>从这里我们就可以看出在函数调用过程中runtime会根据SEl识别子进行寻找，在例子中我们有相应的识别可以查询，如果没有相应的识别子呢？</p>
<blockquote>
<p>在系统中如果在查找过程中没有找到相应的选择子，就会调用上面的函数<br>+(BOOL)resolveInstanceMethod:(SEL)sel；生成实例方法，如上面例子（添加相应的实例方法可以实现，就跳转方法实现）。把添加方法放入到缓存中，可以供我们进行下次的调用</p>
</blockquote>
<p>如果上面我们找到相应的识别子，就会进行第二次对选择子进行相关的处理。</p>
<h3 id="2备援接收到"><a href="#2备援接收到" class="headerlink" title="2备援接收到"></a>2备援接收到</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line">具体实例如下：</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"sihai"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统会把选择子作为参数，返回给我们一个选择子对象。运行的系统就会对相关方法实例进行查找，如果找到相关方法就实行，找不到就结束转发。</p>
<h3 id="3完整的消息传递"><a href="#3完整的消息传递" class="headerlink" title="3完整的消息传递"></a>3完整的消息传递</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br><span class="line">实现的具体方法如下：</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"sihai"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line"></span><br><span class="line">        anInvocation.selector = <span class="keyword">@selector</span>(fly);</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上面2步骤中返回依然是nil，也会执行完整的消息传输消息机制。在该方法中我们可以改变其目标，然后运行系统就会根据改变的目标，在其目标中查询实现方法别调用。当然也可以进行修改选择子。</p>
<h3 id="如果方法调用失败"><a href="#如果方法调用失败" class="headerlink" title="如果方法调用失败"></a>如果方法调用失败</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>通过对于[self method];方法的实现过程的进行探究我们我们可以了解到在消息传递过程是如何实现的，而且我们可以更具我们需求对其中的方法进行相应的而修改。</p>
<blockquote>
<p>runtime是Objc语言特性，本人通过对于的研究理解是：通过runtime我们可以等到我们类中所有元素的资料信息，可以使用期同工的API对类进行我们想到达到的目的；在我们调试过程中也可以通过打印来简化我们调试信息；最棒的就是我们可以了解程序运行过程可以在开发中使我们更加得心应手。</p>
</blockquote>
<p><br></p>
<h3 id="参考来之："><a href="#参考来之：" class="headerlink" title="参考来之："></a>参考来之：</h3><p><a href="http://www.cocoachina.com/ios/20151015/13769.html" target="_blank" rel="external">Runtime初涉之消息转发</a><br><br><br><a href="http://www.cocoachina.com/ios/20150901/13173.html" target="_blank" rel="external">学习runtime的理解和心得</a><br><br><br><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418-CH1g-88778" target="_blank" rel="external">runtime 源码</a><br><br><a href="http://www.jianshu.com/p/f900de4a1495#" target="_blank" rel="external">OC刨根问底-Runtime简单粗暴理解</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/05/29/runtime理解/" data-id="ciqnzuqlo000wq7425u28jk7m" class="article-share-link">分享到</a><div class="tags"><a href="/tags/IOS/">IOS</a></div><div class="post-nav"><a href="/2016/05/29/IOS整体框架/" class="pre">IOS整体框架</a><a href="/2016/05/29/Fastlane讲解/" class="next">Fastlane讲解</a></div><div id="disqus_thread"><script>var disqus_shortname = 'JackJin## Your disqus_shortname, e.g. username';
var disqus_identifier = '2016/05/29/runtime理解/';
var disqus_title = 'runtime理解';
var disqus_url = 'http://yoursite.com/2016/05/29/runtime理解/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//JackJin## Your disqus_shortname, e.g. username.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/第三方框架/">第三方框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-图层-动画/">视图&图层&动画</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/IOS/" style="font-size: 15px;">IOS</a> <a href="/tags/IOS基础知识/" style="font-size: 15px;">IOS基础知识</a> <a href="/tags/三方框架解析/" style="font-size: 15px;">三方框架解析</a> <a href="/tags/图片视频/" style="font-size: 15px;">图片视频</a> <a href="/tags/视频心得/" style="font-size: 15px;">视频心得</a> <a href="/tags/博客之初/" style="font-size: 15px;">博客之初</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/UIView&CALayer&Core Animation~1/">UIView & CALayer& Core Animation ~ （UIView 和 CALayer）（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/UIView&CALayer&Core Animation-总体/">UIView&CALayer&Core Animation~开篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/15/IOS 10/">IOS 10.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/04/SDWebImage之图片缓存分析/">SDWebImage之图片缓存处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/03/SDWebImage/">SDWebImage之图片下载</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/02/IOS面试梳理&自己理解&详细资料库/">IOS面试&自己理解&详细资料库</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最新评论</i></div><script type="text/javascript" src="//JackJin## Your disqus_shortname, e.g. username.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="https://github.com/boilWater" title="Github" target="_blank">Github</a><ul></ul><a href="http://weibo.com/u/2815612403?is_all=1" title="微博" target="_blank">微博</a><ul></ul><a href="http://www.jianshu.com/users/c48ed5ae3925/latest_articles" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">JackJin's 博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
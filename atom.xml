<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JackJin&#39;s 博客</title>
  <subtitle>一位脚踏实地，拥有梦想的90后，想要一直努力追上你！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-29T04:56:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JackJin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>runtime理解</title>
    <link href="http://yoursite.com/2016/05/29/runtime%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/05/29/runtime理解/</id>
    <published>2016-05-29T04:15:38.000Z</published>
    <updated>2016-05-29T04:56:01.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/Users/liangbai/highlight/styles/xcode.css&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;/Users/liangbai/highlight/highlight.pack.js&quot;&gt;&lt;/script&gt;  
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;



&lt;p&gt;网上其实有很多关于讲述runtime的学习资料，也是站在巨人肩上看的更远。写这篇文章也是对于其他人借鉴和翻阅源码，向源码寻求解释吧。&lt;/p&gt;
&lt;p&gt;####runtime简介&lt;br&gt;Objc被我们成为动态语言，换句话说就是把我们平时看到一些关键方法由编译连接推迟到运行时执行。Objc底层是基于C/C++的编译语言，在C/C++项目运行过程中编译、链接生成可执行文件。而Objc语言是在执行过程中进行编译源码，这也是Objc中自己特色：动态类型，动态绑定和动态加载。获runtime的源码点击&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里我们主要探究runtime.h和message.h两个文件夹中一些使用方法。&lt;br&gt;下面列出runtime.h文件中代码：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;typedef struct objc_method &lt;em&gt;Method;  //代表类定义当中的使用方法&lt;br&gt;&lt;/em&gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;typedef struct objc_ivar Ivar;  //代表类定义中实例变量和属性&lt;br&gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;typedef struct objc_category &lt;em&gt;Category; //代表添加成员函数&lt;br&gt;&lt;/em&gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;typedef struct objc_property objc_property_t; //声明的属性&lt;br&gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;struct objc_class {&lt;br&gt;    Class isa;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;#if !&lt;strong&gt;OBJC2&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class super_class                                        OBJC2_UNAVAILABLE;
const char *name                                         OBJC2_UNAVAILABLE;
long version                                             OBJC2_UNAVAILABLE;
long info                                                OBJC2_UNAVAILABLE;
long instance_size                                       OBJC2_UNAVAILABLE;
struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#endif&lt;br&gt;}&lt;br&gt;OBJC2_UNAVAILABLE;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;####看其中一种实现方式&lt;/p&gt;
&lt;p&gt;其中我们就以类中struct objc_ivar_list *ivars ,为例来看是怎样实现&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;struct objc_ivar_list {&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int ivar_count                                           OBJC2_UNAVAILABLE;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#ifdef &lt;strong&gt;LP64&lt;/strong&gt;&lt;br&gt;    int space                                                OBJC2_UNAVAILABLE;&lt;/p&gt;
&lt;p&gt;#endif&lt;br&gt;    /&lt;em&gt; variable length structure &lt;/em&gt;/&lt;br&gt;    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;&lt;br&gt;}                                                            OBJC2_UNAVAILABLE;&lt;br&gt;&lt;br&gt;可以看出实例变量和属性是存放时一个struct的list的数组中，其中包括list的数目、所占空间和基本储存objc_ivar。&lt;br&gt;&lt;br&gt;上面objc_ivar在runtime.h中形式：&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;typedef struct objc_ivar Ivar;&lt;br&gt;&lt;/code&gt;&lt;br&gt;&lt;/pre&gt;objc_ivar中实例变量储存方式：&lt;pre&gt;&lt;br&gt;struct objc_ivar {&lt;br&gt;&lt;code&gt;&lt;br&gt;    char &lt;em&gt;ivar_name                       OBJC2_UNAVAILABLE;&lt;br&gt;    char &lt;/em&gt;ivar_type                       OBJC2_UNAVAILABLE;&lt;br&gt;    int ivar_offset                      OBJC2_UNAVAILABLE;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#indef _LP64_
int space                             OBJC2_UNAVAILABLE;
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;}从上面可以看出类的实例变量和属性经过runtime编译后是以struct的储存形式存在，并且单个实例变量保存其名字、类型、偏移量和储存空间。类中所有实例变量是以list类型进行储存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过对runtime.h文件源码分析我们可以看出，在IOS程序运行过程中把我们类中元素编译为C/C++形式。且编译过程是一个动态过程，所以我们可以通过此方式对我们程序进行动态操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;####runtime动态操作&lt;/p&gt;
&lt;ul&gt;在动态编译过程中无论是属性、实例变量、成员函数、类方法的均可以操作，一下就以比较简单的进行讲解&lt;br&gt;&lt;li&gt;获取类的对象名&lt;/li&gt;&lt;br&gt;&lt;li&gt;获取类中成实例变量和属性&lt;/li&gt;&lt;br&gt;&lt;li&gt;动态添加方法&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;

&lt;p&gt;######获取类的对象名&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;unsigned int count = 0;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Class *classes = objc_copyClassList(&amp;amp;count);&lt;/p&gt;
&lt;p&gt;for (int i = 0; i &amp;lt; count; i++) {&lt;/p&gt;
&lt;p&gt;const char *name = class_getName(classes[i]);&lt;/p&gt;
&lt;p&gt;NSLog(@”%s”, name);&lt;br&gt;}&lt;br&gt;打印出的内容可能出乎你的意料！&lt;/p&gt;
&lt;p&gt;######获取类的实例变量和属性&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;Class clazz = NSClassFromString(@”Graduater”);&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int count = 0;

Ivar *var = class_copyIvarList(clazz, &amp;amp;count);

for (int i = 0; i &amp;lt; count; i++) {
    const char *name = ivar_getName(var[i]);
    NSLog(@&amp;quot;%s&amp;quot;, name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我定义一个毕业生类，然后就可以打印出其中的函数实例变量和属性（不多记得要引入&lt;objc runtime.h=&quot;&quot;&gt;的头文件）；&lt;/objc&gt;&lt;/p&gt;
&lt;p&gt;######动态的添加方法&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;#import &lt;objc runtime.h=&quot;&quot;&gt;&lt;/objc&gt;&lt;/p&gt;
&lt;p&gt;void abc(id self, SEL _cmd){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSLog(@&amp;quot;%@hello&amp;quot;, self);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;@implementation Graduater&lt;/p&gt;
&lt;p&gt;+(BOOL)resolveInstanceMethod:(SEL)sel{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ([NSStringFromSelector(sel) isEqualToString:@&amp;quot;sihai&amp;quot;]) {
    class_addMethod(self, sel, abc, &amp;quot;v@:&amp;quot;);
}
return YES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;&lt;br&gt;然后在函数调用时执行下列：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt; Graduater *graduate = [[Graduater alloc] init];&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt; [graduate performSelector:@selector(sihai) withObject:nil];&lt;br&gt;执行的结果可以条用我们添加的@select(abc)的方法。&lt;/p&gt;
&lt;p&gt;#####runtime使用API的介绍：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;const char * class_getName(Class cls) //获取class的名字&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;BOOL class_addIvar(Class cls, const char &lt;em&gt;name, size_t size, uint8_t alignment, const char &lt;/em&gt;types)  //增添实例变量&lt;/p&gt;
&lt;p&gt;objc_property_t  class_getProperty(Class cls, const char *name) //获取属性&lt;/p&gt;
&lt;p&gt;objc_property_t &lt;em&gt; class_copyPropertyList(Class cls, unsigned int &lt;/em&gt;outCount) //获取属性列表&lt;/p&gt;
&lt;p&gt;Method class_getInstanceMethod(Class aClass, SEL aSelector) //获取方法&lt;/p&gt;
&lt;p&gt;objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes) //添加动态类&lt;br&gt;除去上面我们列举其中极少数的调用实例，如果想了解更多点击&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418-CH1g-211911&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在使用runtime过程，对于操作对象实行方法改善&lt;br&gt;对于对象进行相关操作一般以objc&lt;em&gt;开头&lt;br&gt;对于类的对象进行操作一般以class&lt;/em&gt;开头&lt;br&gt;对于使用方法对象操作一般以method&lt;em&gt;开头&lt;br&gt;对于使用申明属性（property）一般是以property&lt;/em&gt;开头&lt;br&gt;对于使用类成员变量一般使用ivar_开头&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;####消息传送机制&lt;br&gt;在IOS的一个类中我们调用方法使用也是比较多，如&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;[self method];&lt;br&gt;&lt;/pre&gt;但是在runtime编译过程中具体实现的方式是什么呢？&lt;br&gt;首先我们看先message.h中的源码&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;/* Basic Messaging Primitives&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On some architectures, use objc_msgSend_stret for some struct return types.&lt;/li&gt;
&lt;li&gt;On some architectures, use objc_msgSend_fpret for some float return types.&lt;/li&gt;
&lt;li&gt;These functions must be cast to an appropriate function pointer type &lt;/li&gt;
&lt;li&gt;before being called. */&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OBJC_EXPORT id objc_msgSend(id self, SEL op, …);&lt;/p&gt;
&lt;p&gt;OBJC_EXPORT id objc_msgSendSuper(struct objc_super *super, SEL op, …);&lt;br&gt;从上面的解释我们可以的出如果返回类型为float调用objc_msgSend_fpret，如果是数据结构返回使用objc_msgSend_stret。而我们讲解时使用 objc_msgSend(id self, SEL op, …)，就像我们上面的例子就会转化为objc_msgSend(self @select(method))，但是找到我们所使用的方法具体是怎么实现的？&lt;/p&gt;
&lt;p&gt;#####消息转发机制具体实现&lt;br&gt;在动态添加方法过程中，我们使用如下方式：&lt;/p&gt;
&lt;p&gt;######1动态解析方法&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;+(BOOL)resolveInstanceMethod:(SEL)sel;&lt;br&gt;&lt;/code&gt;&lt;br&gt;&lt;/pre&gt;具体实例如下：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;+(BOOL)resolveInstanceMethod:(SEL)sel{&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;if ([NSStringFromSelector(sel) isEqualToString:@”sihai”])&lt;br&gt; {&lt;/p&gt;
&lt;p&gt;   class_addMethod(self, sel, abc, “v@:”);&lt;/p&gt;
&lt;p&gt;   return YES;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;   return NO;&lt;/p&gt;
&lt;p&gt;}&lt;br&gt;从这里我们就可以看出在函数调用过程中runtime会根据SEl识别子进行寻找，在例子中我们有相应的识别可以查询，如果没有相应的识别子呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在系统中如果在查找过程中没有找到相应的选择子，就会调用上面的函数&lt;br&gt;+(BOOL)resolveInstanceMethod:(SEL)sel；生成实例方法，如上面例子（添加相应的实例方法可以实现，就跳转方法实现）。把添加方法放入到缓存中，可以供我们进行下次的调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果上面我们找到相应的识别子，就会进行第二次对选择子进行相关的处理。&lt;/p&gt;
&lt;p&gt;######2备援接收到&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;-(id)forwardingTargetForSelector:(SEL)aSelector;&lt;br&gt;&lt;/code&gt;&lt;br&gt;&lt;/pre&gt;具体实例如下：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;-(id)forwardingTargetForSelector:(SEL)aSelector{&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ([NSStringFromSelector(aSelector) isEqualToString:@&amp;quot;sihai&amp;quot;]) {
    return self;
}
    return [super forwardingTargetForSelector:aSelector];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;系统会把选择子作为参数，返回给我们一个选择子对象。运行的系统就会对相关方法实例进行查找，如果找到相关方法就实行，找不到就结束转发。&lt;/p&gt;
&lt;p&gt;######3完整的消息传递&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;-(void)forwardInvocation:(NSInvocation *)anInvocation;&lt;br&gt;&lt;/code&gt;&lt;br&gt;&lt;/pre&gt;实现的具体方法如下：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;-(NSMethodSignature*)methodSignatureForSelector:(SEL)aSelector{&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ([NSStringFromSelector(aSelector) isEqualToString:@&amp;quot;sihai&amp;quot;]) {
    return [NSMethodSignature signatureWithObjCTypes:&amp;quot;v@:&amp;quot;];
}
return [super methodSignatureForSelector:aSelector];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;-(void)forwardInvocation:(NSInvocation *)anInvocation{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;anInvocation.selector = @selector(fly);
[anInvocation invokeWithTarget:self];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;&lt;br&gt;如果上面2步骤中返回依然是nil，也会执行完整的消息传输消息机制。在该方法中我们可以改变其目标，然后运行系统就会根据改变的目标，在其目标中查询实现方法别调用。当然也可以进行修改选择子。&lt;/p&gt;
&lt;p&gt;######如果方法调用失败&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;-(void)doesNotRecognizeSelector:(SEL)aSelector;&lt;br&gt;&lt;/code&gt;&lt;br&gt;&lt;/pre&gt;通过对于[self method];方法的实现过程的进行探究我们我们可以了解到在消息传递过程是如何实现的，而且我们可以更具我们需求对其中的方法进行相应的而修改。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;runtime是Objc语言特性，本人通过对于的研究理解是：通过runtime我们可以等到我们类中所有元素的资料信息，可以使用期同工的API对类进行我们想到达到的目的；在我们调试过程中也可以通过打印来简化我们调试信息；最棒的就是我们可以了解程序运行过程可以在开发中使我们更加得心应手。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;######参考来之：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20151015/13769.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Runtime初涉之消息转发&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20150901/13173.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;学习runtime的理解和心得&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418-CH1g-88778&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;runtime 源码&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/Users/liangbai/highlight/styles/xcode.css&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;/Users/liangbai/highlight/highlight.pack.js&quot;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
      <category term="IOS" scheme="http://yoursite.com/tags/IOS/"/>
    
      <category term="[object Object]" scheme="http://yoursite.com/tags/object-Object/"/>
    
  </entry>
  
  <entry>
    <title>Fastlane讲解</title>
    <link href="http://yoursite.com/2016/05/29/Fastlane%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/05/29/Fastlane讲解/</id>
    <published>2016-05-29T04:13:46.000Z</published>
    <updated>2016-05-29T04:55:14.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/Users/liangbai/highlight/styles/xcode.css&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;/Users/liangbai/highlight/highlight.pack.js&quot;&gt;&lt;/script&gt;  
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;


&lt;p&gt;大概在一个月左右写过关于cocoaPods安装和使用方法，如果说cocoaPods是我们盾牌（可以让我们在开发过程中专注实现代码部分），那么fastlane就会是我们开发过程中的长矛（帮助我们在开发过程中提交测试、快速发布）。&lt;br&gt;想知道fastlane了解点击&lt;a href=&quot;https://fastlane.tools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;br&gt;&lt;/a&gt;获取fastlan的github下载点击&lt;a href=&quot;https://github.com/fastlane/fastlane&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;####fastlane安装&lt;br&gt;fastlane是基于Ruby的开发脚本集合有助于我们在IOS开发过程中达到简便的开发。如果你在自己MAC上已经安装Ruby及其环境，只需要执行下列安装就可以实现安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
sudo gem install fastlane --verbose
&lt;/code&gt;
&lt;/pre&gt;确定自己安装的是最新版本的Xcode:
&lt;pre&gt;
&lt;code&gt;
Xcode-select --install
&lt;/code&gt;
&lt;/pre&gt;如果在启动fastlane比较慢的情况可以执行:
&lt;pre&gt;
&lt;code&gt;
gem cleanup
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;####fastlane使用具体方法和具体功能&lt;br&gt;了解具体使用点击&lt;a href=&quot;https://github.com/fastlane/fastlane/tree/master/deliver&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;br&gt;&lt;li&gt;deliver：上传屏幕截图、二进制程序数据和应用程序到AppStore&lt;/li&gt;&lt;br&gt;&lt;li&gt;snapshot：自动截取你的程序在每个设备上的图片&lt;/li&gt;&lt;br&gt;&lt;li&gt;frameit：应用截屏外添加设备框架&lt;/li&gt;&lt;br&gt;&lt;li&gt;pem：可以自动化地生成和更新应用推送通知描述文件&lt;/li&gt;&lt;br&gt;&lt;li&gt;sigh：生成下载开发商店的配置文件&lt;/li&gt;&lt;br&gt;&lt;li&gt;pilot：最好的在终端管理测试和建立的文件&lt;/li&gt;&lt;br&gt;&lt;li&gt;boarding：很容易的方式邀请你测试beta测试&lt;/li&gt;&lt;br&gt;&lt;li&gt;gyp：建立新的发布的版本&lt;/li&gt;&lt;br&gt;&lt;li&gt;match：使用git同步你成员间的开发者证书和文件配置&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;

&lt;p&gt;####fastlane举例：&lt;br&gt;使用deliver自动打包我们App提交到AppStore，官方使用点击&lt;a href=&quot;https://github.com/fastlane/fastlane/tree/master/deliver&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;打开终端进行我们项目所在的floder，我的项目是在桌面上名称是hello
&lt;code&gt;
cd ~/desktop/hello
&lt;/code&gt;
然后输入：
&lt;code&gt;
deliver init
&lt;/code&gt;&lt;br&gt;
然后输入我们的Apple ID Username:
再输入我们的Password 
&lt;/pre&gt;

&lt;p&gt;####fastlane使用场景&lt;/p&gt;
&lt;p&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;在我们开发后每次提交时执行的测试（有team的单元测试和团队开发的集成测试）(pilot)&lt;/li&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;构建我们使用的Bate版本时（boarding）&lt;/li&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;开发好项目需要提给界面截图时(snapshot)&lt;/li&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;构建并分发至应用商店（这包括更新配置文件，创建新的屏幕截图，上传应用至应用商店并提交应用）(deliver)&lt;/li&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;####fastlane典型的开发流程&lt;br&gt;此开发流程也是我们团队开发过程中基本开发顺序&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;lane :appstore do&lt;br&gt;  increment_build_number&lt;br&gt;  cocoapods&lt;br&gt;  xctool&lt;br&gt;  snapshot&lt;br&gt;  sigh&lt;br&gt;  deliver&lt;br&gt;  frameit&lt;br&gt;  sh “./customScript.sh”&lt;br&gt;&lt;br&gt;&lt;br&gt;  slack&lt;br&gt;end&lt;br&gt;&lt;/code&gt;&lt;br&gt;&lt;/pre&gt;&lt;br&gt;cocoaPods帮助我们管理三方开源库，fastlane可以在我们开发过程中简化我们开发过程以及简化我们发布流程。如果要提高自己IOS方面能力需要我们进一步深入研究。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/Users/liangbai/highlight/styles/xcode.css&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;/Users/liangbai/highlight/highlight.pack.js&quot;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
      <category term="IOS" scheme="http://yoursite.com/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>block，注册监听，委托协议和KVO</title>
    <link href="http://yoursite.com/2016/05/29/block%EF%BC%8C%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%EF%BC%8C%E5%A7%94%E6%89%98%E5%8D%8F%E8%AE%AE%E5%92%8CKVO/"/>
    <id>http://yoursite.com/2016/05/29/block，注册监听，委托协议和KVO/</id>
    <published>2016-05-29T04:12:40.000Z</published>
    <updated>2016-05-29T04:55:43.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/Users/liangbai/highlight/styles/xcode.css&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;/Users/liangbai/highlight/highlight.pack.js&quot;&gt;&lt;/script&gt;  
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;

&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;IOS中关于信息传递过程中经常会使用block，委托代理，NSNotification，KVO进行调用，但是查找资料后有些资料不是很全。&lt;/p&gt;
&lt;p&gt;#####四者总体比较然后进行一一详解进行讲解：&lt;/p&gt;
&lt;p&gt;block：一对一进行通信，比起其他三者更加简洁，但是事件比较多时可以使用delegate。&lt;br&gt;委托代理：和block一样是一对一，我们使用时要先进行协议方法然后实现协议代理，如果需要通信就需要实现代理。&lt;br&gt;NSNotification：在进行注册监听时，可以进行一对多的情况，一个进行注册可以多种情况下进行监听。&lt;br&gt;KVO：就是我们所说的键值监听模式，其主要是在KVC基础上完后才能。&lt;/p&gt;
&lt;p&gt;以前读过一个砍柴的故事，如果我们想要追求搞得效率就要对所用到的工具了解，下面我们就开始磨我们搜中的刀。 &lt;/p&gt;
&lt;p&gt;#####block的来龙去脉：&lt;br&gt;block是IOS SDK 4.0中引入的，block在IOS中实际就是一个代码块，有点像C++中内联函数inline有点相似，最让人惊奇的是我们还可以向其传递参数。闲来没事想要知道block在C++中的具体实现就是用Clang编辑^{printf”Hello, World!”}()，此时我们在block仅仅是输出一个语句。&lt;br&gt;//hello.c是我们把想要编辑的内容放置的文件名称&lt;/p&gt;
&lt;p&gt;######block在没有传入参数情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ clang -rewrite-objc hello.c &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;在编译后再文件后会生成 hello.cpp文件&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;struct __mian_block_impl_0 &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{&lt;br&gt;  struct &lt;strong&gt;block_impl impl;&lt;br&gt;  struct &lt;/strong&gt;mian_block_desc_0* Desc;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;mian_block_impl_0(void *fp, struct &lt;/strong&gt;mian_block_desc_0 *desc, int flags=0)&lt;/p&gt;
&lt;p&gt; {    impl.isa = &amp;amp;_NSConcreteStackBlock;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;impl.Flags = flags;
impl.FuncPtr = fp;
Desc = desc;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;static void &lt;strong&gt;mian_block_func_0(struct &lt;/strong&gt;mian_block_impl_0 *__cself) &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{&lt;br&gt;     printf(“Hello, World!\n”);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;static struct __mian_block_desc_0 {&lt;/p&gt;
&lt;p&gt;  size_t reserved;&lt;br&gt;  size_t Block_size;&lt;/p&gt;
&lt;p&gt;} &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;mian_block_desc_0_DATA = { 0, sizeof(struct &lt;/strong&gt;mian_block_impl_0)&lt;br&gt;};&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;int mian(){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;((void (*)())&amp;amp;__mian_block_impl_0((void *)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;mian_block_func_0, &amp;amp;&lt;/strong&gt;mian_block_desc_0_DATA)) ();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return 0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static struct IMAGE_INFO&lt;br&gt;{ unsigned version; unsigned flag; } &lt;/p&gt;
&lt;p&gt;_OBJC_IMAGE_INFO = { 0, 2 };&lt;br&gt;&lt;br&gt;&lt;br&gt;上面的代码既是我们通过编译截取的hello.cpp的具体代码，根据上面代码我们可以看到block实际是struct结构。看出_mian_block_impl_0 其中传入其中也是block_impl&amp;amp;mian_block_desc_0两个block，下面是_mian_block_impl_0的构造函数。&lt;/p&gt;
&lt;p&gt;######block在有传入参数情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;clang -rewrite-objc hello1.c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样在我们编译过后会生成hello.cpp&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;struct __mian_block_impl_0 {&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;  struct __block_impl impl;&lt;/p&gt;
&lt;p&gt;  struct __mian_block_desc_0* Desc;&lt;/p&gt;
&lt;p&gt;  float perperson;&lt;br&gt;  &lt;strong&gt;mian_block_impl_0(void *fp, struct &lt;/strong&gt;mian_block_desc_0 &lt;/p&gt;
&lt;p&gt;*desc, float _perperson, int flags=0) : perperson(_perperson)&lt;br&gt; {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;impl.isa = &amp;amp;_NSConcreteStackBlock;
impl.Flags = flags;
impl.FuncPtr = fp;
Desc = desc;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;br&gt;};&lt;/p&gt;
&lt;p&gt;static float &lt;strong&gt;mian_block_func_0(struct &lt;/strong&gt;mian_block_impl_0 *__cself, &lt;/p&gt;
&lt;p&gt;int totalNum) {&lt;/p&gt;
&lt;p&gt;  float perperson = __cself-&amp;gt;perperson; // bound by copy&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    return perperson * totalNum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;static struct __mian_block_desc_0 {&lt;/p&gt;
&lt;p&gt;  size_t reserved;&lt;br&gt;  size_t Block_size;&lt;br&gt;}&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;mian_block_desc_0_DATA = { 0, sizeof(struct &lt;/strong&gt;mian_block_impl_0)};&lt;/p&gt;
&lt;p&gt;int mian(){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float perperson = 34.5;
float (*sunClassFee)(int) = ((float (*)(int))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;amp;&lt;strong&gt;mian_block_impl_0((void *)&lt;/strong&gt;mian_block_func_0, &amp;amp;__mian_block_desc_0_DATA, &lt;/p&gt;
&lt;p&gt;perperson));&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return 0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static struct IMAGE_INFO { unsigned version; unsigned flag; } &lt;/p&gt;
&lt;p&gt;_OBJC_IMAGE_INFO = { 0, 2 };&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;可以看出在block中使用外部变量perperson时，block初始化时这样的：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;是在&lt;strong&gt;mian_block_impl_0进行初始化perperson，在block构造时作为block的其中&lt;br&gt;一个成员初始。在访问时通过&lt;/strong&gt;cself-&amp;gt;perperson指针进行访问。&lt;br&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;######block在有传入参数情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;clang -rewrite-objc hello2.c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;struct __Block_byref_perperson_0 {&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;  void *__isa;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Block_byref_perperson_0 *&lt;/strong&gt;forwarding;&lt;br&gt;  int __flags;&lt;/p&gt;
&lt;p&gt; int __size;&lt;br&gt; float perperson;&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;struct __mian_block_impl_0 {&lt;/p&gt;
&lt;p&gt;  struct &lt;strong&gt;block_impl impl;&lt;br&gt;  struct &lt;/strong&gt;mian_block_desc_0* Desc;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;Block_byref_perperson_0 *perperson; // by ref
  &lt;/strong&gt;mian_block_impl_0(void &lt;em&gt;fp, struct __mian_block_desc_0 &lt;/em&gt;desc, &lt;/p&gt;
&lt;p&gt; __Block_byref_perperson_0 *_perperson, int flags=0) : &lt;/p&gt;
&lt;p&gt;perperson(_perperson-&amp;gt;__forwarding) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;impl.isa = &amp;amp;_NSConcreteStackBlock;
impl.Flags = flags;
impl.FuncPtr = fp;
Desc = desc;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;br&gt;};&lt;/p&gt;
&lt;p&gt;static float &lt;strong&gt;mian_block_func_0(struct &lt;/strong&gt;mian_block_impl_0 *__cself,&lt;/p&gt;
&lt;p&gt; int totalNum) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__Block_byref_perperson_0 *perperson = __cself-&amp;gt;perperson; // bound by ref
 (perperson-&amp;gt;__forwarding-&amp;gt;perperson) = (perperson-&amp;gt;__forwarding-&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;perperson) + 6;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    return (perperson-&amp;gt;__forwarding-&amp;gt;perperson) * totalNum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;static void &lt;strong&gt;mian_block_copy_0(struct &lt;/strong&gt;mian_block_impl_0*dst, &lt;/p&gt;
&lt;p&gt;struct __mian_block_impl_0*src) &lt;/p&gt;
&lt;p&gt;{_Block_object_assign((void*)&amp;amp;dst-&amp;gt;perperson, &lt;/p&gt;
&lt;p&gt;(void&lt;em&gt;)src-&amp;gt;perperson, 8/&lt;/em&gt;BLOCK_FIELD_IS_BYREF*/);}&lt;/p&gt;
&lt;p&gt;static void &lt;strong&gt;mian_block_dispose_0(struct &lt;/strong&gt;mian_block_impl_0*src) {&lt;/p&gt;
&lt;p&gt;_Block_object_dispose((void&lt;em&gt;)src-&amp;gt;perperson, 8/&lt;/em&gt;BLOCK_FIELD_IS_BYREF*/);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static struct __mian_block_desc_0 {&lt;br&gt;  size_t reserved;&lt;br&gt;  size_t Block_size;&lt;/p&gt;
&lt;p&gt;  void (&lt;em&gt;copy)(struct __mian_block_impl_0&lt;/em&gt;, struct __mian_block_impl_0*);&lt;/p&gt;
&lt;p&gt;  void (&lt;em&gt;dispose)(struct __mian_block_impl_0&lt;/em&gt;);&lt;br&gt;} __mian_block_desc_0_DATA = { &lt;/p&gt;
&lt;p&gt;0, sizeof(struct &lt;strong&gt;mian_block_impl_0), &lt;/strong&gt;mian_block_copy_0, &lt;/p&gt;
&lt;p&gt;__mian_block_dispose_0};&lt;br&gt;int mian(){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__attribute__((__blocks__(byref))) __Block_byref_perperson_0 perperson = {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(void&lt;em&gt;)0,(__Block_byref_perperson_0 &lt;/em&gt;)&amp;amp;perperson, 0, &lt;/p&gt;
&lt;p&gt;sizeof(__Block_byref_perperson_0), 34.5&lt;br&gt;};&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float (*sunClassFee)(int) = ((float (*)(int))&amp;amp;__mian_block_impl_0((void *)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;mian_block_func_0, &amp;amp;&lt;/strong&gt;mian_block_desc_0_DATA, &lt;/p&gt;
&lt;p&gt;(__Block_byref_perperson_0 *)&amp;amp;perperson, 570425344));&lt;br&gt;    return 0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static struct IMAGE_INFO { unsigned version; unsigned flag; } &lt;/p&gt;
&lt;p&gt;_OBJC_IMAGE_INFO = { 0, 2 };&lt;br&gt;&lt;br&gt;&lt;br&gt;我们在对于block外的perperson计算重新复制，和上面在block仅仅在block中使用外面的参数。两者经过对比可以看出：在block中对于外部值进行复制，会出现下面的情况。使用clang对于block进行编码，可以看书对于perperson进行_block的修饰后编码生成Block_byref_perperson_0的struct结构体，其中__Block_byref_perperson_0的指针指向在block中perperson的地址。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;struct &lt;strong&gt;Block_byref_perperson_0 {&lt;br&gt;  void *&lt;/strong&gt;isa;&lt;br&gt; &lt;strong&gt;Block_byref_perperson_0 *&lt;/strong&gt;forwarding;  int &lt;strong&gt;flags;&lt;br&gt; int &lt;/strong&gt;size; float perperson;&lt;br&gt;};&lt;br&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;#####block的使用方法~传入参数：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;  int (^isInputEven)(int) = ^(int n){&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (n&amp;gt;1) {
       return n*isInputEven(n-1);
    }else{
       return 1;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; };&lt;br&gt;&lt;br&gt;&lt;br&gt;上面我们定义一个block代码段，代码的实现功能是利用递归计算n的基乘。代码可以作为整个代码块进行调用，而且在调用过程中我们只需isInputEven（）函数名和传入参数即可实现。&lt;/p&gt;
&lt;p&gt;#####block的使用方法~使用外部参数参数：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;float perperson = 34.5;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float (^sunClassFee)(int) = ^(int totalNum){
    return perperson * totalNum;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;};&lt;br&gt;&lt;br&gt;&lt;br&gt;使用外部参数perperson，让我们感觉block可以想一个类一样使用socpe里面的变量目前无法做到。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;主要原因是因为：在block的编译过程中我们看到，在block中进行访问其中元素时需要是&lt;br&gt;block默认构造函数对于block其中的元素访问。&lt;br&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;#####block的使用方法~使用外部参数参数：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;__block float perperson = 34.5;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float (^sunClassFee)(int) = ^(int totalNum){
    perperson = perperson + 6;
    return perperson * totalNum;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; };&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;#####block的使用方法~在（UIView）的动画中使用：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt;[UIView animateWithDuration:3.0f animations:^{&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;view.alpha = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }];&lt;br&gt;&lt;br&gt;&lt;br&gt;IOS的开发到今天差不多已经有7年之久，block在开发中使用广度越来越广泛：&lt;/p&gt;
&lt;p&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;枚举–来过去对象。例如：NSDictionary的枚举过程&lt;/li&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;UIView–对于UIView的动画设置，后面有机会会对动画专门讲述…&lt;/li&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;通知–在本文讲述的就是在调用过程中与其他通知不同点所在&lt;/li&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;完成处理–在相应程序结束后，需要对于程序结果的处理。例如：AFNetWork在访问网络后，对于成功和失败进行处理&lt;/li&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;GCD–在GCD的过程中都是含有block使用的方法&lt;/li&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;排序–平时我们使用的一些简单算法均可以block进行相关处理&lt;/li&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;####委托代理详解&lt;br&gt;在发C++过程中经常见到多组继承，但是在IOS开发过程中只能进行单继承，很多方法我们需要实现接口的形式。正如我们在使用UITableView时，经常会用到UITableViewDataSource和UITableViewDelegate。&lt;br&gt;如果要使用使用委托代理，需要知道协议和委托两者关系。&lt;/p&gt;
&lt;p&gt;#####协议&lt;br&gt;协议一般分为两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@ required:        //是我们在继承过程中必须实现的&lt;br&gt;   @optional :        //在实现接口中需要进行选择性实现的方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#####委托&lt;br&gt;常见的一种设计模式，身为老板一般负责管理员工、打电话、发薪水，这样由于公司业务发展就请一个秘书负责：打电话和发薪水。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先进行协议提取（需要员工所得事情）：(boss.h文件中声明)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;@protocol protocol &lt;nsobject&gt;&lt;br&gt;-(void)payoff;&lt;br&gt;-(void)tel;&lt;br&gt;@end&lt;br&gt;@interface boss : NSObject&lt;br&gt;@property(nonatomic,strong) id&lt;protocol&gt; delegate;&lt;br&gt;-(void)manage;&lt;br&gt;-(void)payoff;&lt;br&gt;-(void)tel;&lt;br&gt;@end&lt;br&gt;&lt;/protocol&gt;&lt;/nsobject&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于老板在具体工作的实现：(boss.m文件中实现)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;@implementation boss&lt;br&gt;-(void)manage{&lt;br&gt;    NSLog(@”boss–&amp;gt;manage”);&lt;br&gt;}&lt;br&gt;-(void)payoff{&lt;br&gt;    [self.delegate payoff];&lt;br&gt;}&lt;br&gt;-(void)tel{&lt;br&gt;    [self.delegate tel];&lt;br&gt;}&lt;br&gt;@end&lt;br&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;委托秘书所要做的事物：（在sec.m的文件中实现完成boss的代理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;@interface Sec ()&lt;protocol&gt;&lt;br&gt;@end&lt;br&gt;@implementation Sec&lt;br&gt;-(void)payoff{&lt;br&gt;    NSLog(@”sec–&amp;gt;payoff”);&lt;br&gt;}&lt;br&gt;-(void)tel{&lt;br&gt;    NSLog(@”sec–&amp;gt;tel”);&lt;br&gt;}&lt;br&gt;&lt;/protocol&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;####注册监听小试&lt;br&gt;NSNotificationCenter就相当于广播一样，可以对对象进行一次注册然后有多个监听。就像我们知道如果有注册的话，就需要我们对于对象进行释放（remove）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; [[NSNotificationCenter defaultCenter] postNotificationName:@”clickbt” object:nil];&lt;/p&gt;
&lt;p&gt;[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(click) name:@”clickbt” object:nil];&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上面的代码可以看出我们在使用注册监听时可以进行相关内容传递，需要传递的内容放在object（为id类型）。&lt;br&gt;在remove监听的方法，经过查找资料：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;&lt;code&gt;&lt;br&gt; -(void)viewWillAppear:(BOOL)animated&lt;br&gt;{&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;   [super viewWillAppear:animated];&lt;/p&gt;
&lt;p&gt;   [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:@”clickbt” object:nil];&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;-(void)viewWillDisappear:(BOOL)animated&lt;br&gt;{&lt;/p&gt;
&lt;p&gt;   [super viewWillDisappear:animated];&lt;/p&gt;
&lt;p&gt;   [[NSNotificationCenter defaultCenter] removeObserver:self name:@”clickbt” object:nil];&lt;br&gt;}&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;####KVO简史&lt;br&gt;当我们说起KVO(key-value-observe)时不免想起他的孪生大哥KVC（key-value-coding）。KVO是观察者模式的继承者，基于键值变化监听者，基于KVC基础完成之一。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下列对于界面的UILabel进行监听：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;[self.label addObserver:self forKeyPath:@”narcotics” options:&lt;br&gt;NSKeyValueObservingOptionNew |NSKeyValueObservingOptionOld context:nil];&lt;br&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一旦UILabel发生变化就会调用方法：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;-(void)observeValueForKeyPath:(NSString &lt;em&gt;)keyPath ofObject:(id)object&lt;br&gt;change:(NSDictionary &lt;/em&gt;)change context:(void *)context{&lt;br&gt;     //一旦有所变化调用方法&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;附带：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;KVC：通过设置key值，进行标记。然后通过key值找到进行重新设置，说的通俗点点就是键值对。类似NSDictionary相似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以前经常看些大牛写的博客，在看博客过程中也学到很多知识。心向往之，开始动手写关于自己在IOS成长路上见证。&lt;/p&gt;
&lt;p&gt;###简述block和delegation使用场景的比较&lt;br&gt;我们知道&lt;code&gt;block&lt;/code&gt;和&lt;code&gt;delegation&lt;/code&gt;是关于通信方面，在开发的过程中我们也经常会使用两者。面对具体情况我们需要怎么样做出选着呢？&lt;/p&gt;
&lt;p&gt;#####1.当在一个方法的参数中需要多个对象时使用delegation&lt;br&gt;我们在开发过程中经常使用&lt;code&gt;UITableView&lt;/code&gt;，这时我们就要实现接口协议&lt;code&gt;UITableViewDataSource&lt;/code&gt;, &lt;code&gt;UITableViewDelegate&lt;/code&gt;两者是我们在使用&lt;code&gt;UITableView&lt;/code&gt;的相关数据协议和相关协议。从tableView角度出发：实现展示需要数据、对一些展示过程的控制等，这些可以使用&lt;code&gt;block&lt;/code&gt;来进行实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;void (^ showTableView)(NSData *data, NSInteger number, CGFloat heightForRowAtIndexPath);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面我们定义告诉过程需要参数在&lt;code&gt;NSIndexPath&lt;/code&gt;,所以第三个参数应该是 &lt;code&gt;block&lt;/code&gt;形式。我们上面知道block在编译过程会被编译为&lt;strong&gt;struct&lt;/strong&gt;结构，在相互嵌套过程中使用&lt;code&gt;delegation&lt;/code&gt;更加方便。&lt;/p&gt;
&lt;p&gt;#####2. 一个对象只能有一个delegation&lt;br&gt;由于一个对象只能有一个delegate，而且它只能与这个delegate通信。让我们看看CLLocationManager 这个类，当发现地理位置后，location manager 只会通知一个对象（有且只有一个）。当然，如果我们需要更多的对象去知道这个更新，我们最好创建其他的location manager。&lt;/p&gt;
&lt;p&gt;这里有的人可能想到，如果CLLocationManager是个单例呢？如果我们不能创建CLLocationManager的其他实例，就必须不断地切换delegate指针到需要地理数据的对象上（或者创建一个只有你理解的精密的广播系统）。因此，这样看起来，delegatetion在单例上没有多大意义。&lt;/p&gt;
&lt;p&gt;关于这点，最好的印证例子就是UIAccelerometer。在早期版本的iOS中，单例的 accelerometer 实例有一个delegate，导致我们必须偶尔切换一下。这个愚蠢的问题在之后的IOS版本被修改了，现在，任意一个对象都可以访问CMMotionManager block，而不需要阻止其他的对象来接收更新。&lt;/p&gt;
&lt;p&gt;因此，我们可以得出另一个结论：“如果一个对象是单例，不要使用delegation”。&lt;/p&gt;
&lt;p&gt;#####3. 一般delegation都有自己的而返回值&lt;br&gt;还是拿上面的例子说明：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;-(UITableViewCell &lt;em&gt;)tableView:(UITableView &lt;/em&gt;)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;br&gt;&lt;br&gt;上面是&lt;code&gt;UITableViewDataSource&lt;/code&gt;协议中必须实现协议，可看出是使用返回值。而我们也可以看其他的一些协议表示情况，一般均是需要返回值的。&lt;/p&gt;
&lt;p&gt;#####4.delegation偏向于使用的过程 VS block偏向于使用结果&lt;br&gt;如果查看&lt;code&gt;NSURLConnectionDelegate&lt;/code&gt; 以及 &lt;code&gt;NSURLConnectionDataDelegate&lt;/code&gt;，我们在可以&lt;strong&gt;protocol&lt;/strong&gt;中看到这样的消息：我将要做什么（如： &lt;strong&gt;willSendRequest&lt;/strong&gt;，将要发送请求）、到目前为止我知道的信息（如：&lt;code&gt;canAuthenticateAgainstProtectionSpace&lt;/code&gt;）、我已经完成这些啦（ &lt;strong&gt;didReceiveResponse&lt;/strong&gt;，收到请求的回复，即完成请求）。这些消息组成一个流程，而那些对流程感兴趣的&lt;strong&gt;delegate&lt;/strong&gt;将会在每一步得到相应的通知。&lt;/p&gt;
&lt;p&gt;当我们观察&lt;strong&gt;handler&lt;/strong&gt;和完整的方法时，我们发现一个&lt;strong&gt;block&lt;/strong&gt;包含一个响应对象和一个错误对象。显然这里没有任何有关“我在哪里，我正在做什么的”的交互。&lt;/p&gt;
&lt;p&gt;因此我们可以这样认为，&lt;strong&gt;delegate&lt;/strong&gt;的回调更多的面向过程，而&lt;strong&gt;block&lt;/strong&gt;则是面向结果的。如果你需要得到一条多步进程的通知，你应该使用&lt;strong&gt;delegation&lt;/strong&gt;。而当你只是希望得到你请求的信息（或者获取信息时的错误提示），你应该使用&lt;strong&gt;block&lt;/strong&gt;。（如果你结合之前的3个结论，你会发现&lt;strong&gt;delegate&lt;/strong&gt;可以在所有事件中维持&lt;strong&gt;state&lt;/strong&gt;，而多个独立的&lt;strong&gt;block&lt;/strong&gt;确不能）。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;######参考：&lt;br&gt;&lt;a herf=&quot;http://www.cocoachina.com/ios/20150925/13525.html&quot;&gt;开发该选择Blocks还是Delegates&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/Users/liangbai/highlight/styles/xcode.css&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;/Users/liangbai/highlight/highlight.pack.js&quot;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
      <category term="IOS" scheme="http://yoursite.com/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>从叮叮CTO采访演讲随笔</title>
    <link href="http://yoursite.com/2016/05/29/%E4%BB%8E%E5%8F%AE%E5%8F%AECTO%E9%87%87%E8%AE%BF%E6%BC%94%E8%AE%B2%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2016/05/29/从叮叮CTO采访演讲随笔/</id>
    <published>2016-05-29T04:09:11.000Z</published>
    <updated>2016-05-29T04:55:58.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/Users/liangbai/highlight/styles/xcode.css&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;/Users/liangbai/highlight/highlight.pack.js&quot;&gt;&lt;/script&gt;  
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;


&lt;p&gt;今天在看One’s Cat大神的博客时讲到如何创建我们个人的开源框架，就涉及到fastlane就找来看下，无意中看到叮叮的CTO朱鸿大神（又一尊大神）讲述自己的产品。短短22：05的视频让自己感触很大，写这篇文章也就是无聊说下自己所学知识吧。&lt;/p&gt;
&lt;p&gt;#####总的来说以技术来简化我们生活，目前比想象中要难。&lt;/p&gt;
&lt;p&gt;######人员配置方面&lt;br&gt;首先朱大神讲述团队人数有120人，而在客户端和后端比例2：1估计这样的标配也只有像阿里这样想要在移动端尤其社交这块站住一定地位强悍标配。&lt;/p&gt;
&lt;p&gt;######踩过的大坑&lt;br&gt;朱大神讲述在数据解析方便曾经踩过一个大坑，所谓大坑就是在IOS&amp;amp;Android两个客户端对于数据解析有所不同。就是在于基本数据类型方面对于数据解析产生不同的结果，估计是使用加密方式在服务器得到数据解析有一定乱码想象只是不知道是Json还是Xml得解析（小编自己猜测）。&lt;/p&gt;
&lt;p&gt;######企业电话方面&lt;br&gt;大神说出目前我们移动的端所在2G用户比重挺大，采用融合通信方向期间还是用阿里的线路。关于在WiFi情况下测试使用OA通信方式，随便讲述在手机网络提供商不同的情况下具体情况（联通网络通信一旦打开网络就会占用一条信道进行通信，所以在数据较大时带宽就是占用较大问题~小心脏作为客户端开发的小编之前竟没有听说过）。&lt;/p&gt;
&lt;p&gt;######发布机制和团队意思&lt;br&gt;由于叮叮是基于企业通信服务的行业应用性能方便真是个大问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;嗨，记得去年的暑假在参加深圳一个活动时，黄老大奔去深圳创业~那时我们住在旅社他说要做企业OA，我随口说现在创业那么火要不做一个给创业者做个服务型的应用提高效率。看到这个感觉事情真的不想我们想象的那么简单！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为开发人员我们都知道如何做到流畅滚动界面和通信方面及时，这个是很大的挑战。这个后面有所涉及大家还是耐心看下去。&lt;br&gt;其实真正触动💘项目组技术、产品和运营拆分为7个team，实行竞争估计机制。产品经理对于自己team负责的功能进行跟进，技术和运营负责相关技术开发。这样完成每天都可以进行一个bate的提交，三周进行产品的一次迭代。项目开发之快。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最让小编疑惑的是产品之间功能可以进行模块开发~基于面向对象有点（针对功能实现可以进行模块划分），但是运营是怎么在一个大的team然后7个小团队之间实现😂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得不久前有个标题党：BAT未来还会存在吗？中间就是利用“二八法则”来讲述大企业面对科技什么鬼突变时难以进行改革，小企业更有活力。来辩证讲述自己的观点，看小编微微一笑就喝下水平静平静。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不过目前看来这个定理估计是有自己价值，以后如果是自己出来尝试就可以试验下，此处可以hulue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; ######灰度用户&lt;br&gt;听到的第一感觉就是“恩？”请问和37度灰有关系不。我可是窦文涛的粉丝啊，难道是自己见识太少。认认真真百度一下关于灰度的问题，所说没有找到灰度用户说法但是却看到关于QQ传授灰度法则：需求度、速度、灵活度、冗余度、开放协作度、创新度和进化度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小编下面就为大家讲述下：&lt;br&gt;需求度：用户需求就是使用者最想要。例如：只从去年国家放开二胎政策，我们就会看到今年母婴行业天天火爆的行业，毕竟70，80后大叔和阿姨估计从天就开始人类伟大的传承奋斗啦😛&lt;br&gt;速度：这个估计大家都知道，刘翔110跨栏成为亚洲飞人的称号。对于互联网而言速度就更难能可贵的，估计这也是面对微信的叮叮三周一个版本更新具体体现吧。&lt;br&gt;灵活度：面对当前局势有所判断和对未知的预见，就像神雕侠侣里的段誉，面对强大恶老三（一直都自称老二来着）虽说武术哥不行。但是好在凌波微步，照样在打赌中成为你小子的师傅不是。&lt;br&gt;冗余度：看到这心里凉把把的，QQ老大你也是程序员开始的，冗余度是在程序开发过程中我们想法设法解决。后来定睛一看，哦，原来是是试错啊，好吧奉上我的膝盖👍🏻。&lt;br&gt;开放协作度：在互联网中把自家的资源拿来共享合作，大家都知道蜜蜂一般蜂巢中只有一个蜂后无数工蜂，蜂后向工蜂提供生命工蜂负责具体事务。之后大家在一个集体里把自己越做越大，蜂后后期几乎可以独资。&lt;br&gt;创新度：只记得去年克强大大所得万众创新，大众创业。后面身边很多人就去啦，一路好走🌵&lt;br&gt;进化度：QQ大佬说6个如果做到的话，这个会自动完成。有点生物进化的味道，但是缺少物竞天择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;######问题调试&lt;/p&gt;
&lt;pre&gt;
这里之所使用代码格式是真的有重要，仅对于码农来说，比方说本人。
还像是Android段可以进行fix后台自动修复功能，IOS客户端是在IOS端直接进行修改。
&lt;/pre&gt;

&lt;p&gt;######性能优化要求&lt;br&gt;省电和顺滑，具体怎么完成和实现，朱大神微微😃。当讲到在图片下载处理时主要将海外，朱大神说我们在海外有简历服务器然后跟具体的路由优化选择可以对图片下载加快速度。&lt;/p&gt;
&lt;p&gt;######企业群聊处理&lt;br&gt;假设一种情况：当很多在一个群组中一起聊天，一秒可以让数据达到几千条。请问你怎么解决？&lt;br&gt;朱大神解决方式：一起把数据下载下来，保存不至于丢失。但是最后显示的数据大多是最后十几二十几条。这样可以减少屏幕的刷屏率，优化性能。至少在GPU渲染显示方面肯定有所优化🙅🏻&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
之所以写这些随笔，是想让自己记住自己看过知识。毕竟好记性是在不如一个烂笔头，写的
过程也是在记忆中重新思考的过程。
&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/Users/liangbai/highlight/styles/xcode.css&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;/Users/liangbai/highlight/highlight.pack.js&quot;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="视频心得" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>博客搬家感觉</title>
    <link href="http://yoursite.com/2016/05/28/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%90%AF/"/>
    <id>http://yoursite.com/2016/05/28/博客开启/</id>
    <published>2016-05-28T13:44:27.000Z</published>
    <updated>2016-05-29T04:06:48.000Z</updated>
    
    <content type="html">&lt;p&gt;博客地址有经常使用的博客园搬至简书，从简书搬到Hexo建立的Github上面。从此开启自己在跟人博客学习和分享征程，要是说写这些对我最大驱动力是一个自己一直对技术喜爱和完成自己蜕变之路。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;博客地址有经常使用的博客园搬至简书，从简书搬到Hexo建立的Github上面。从此开启自己在跟人博客学习和分享征程，要是说写这些对我最大驱动力是一个自己一直对技术喜爱和完成自己蜕变之路。&lt;/p&gt;

    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="博客之初" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%88%9D/"/>
    
  </entry>
  
</feed>
